"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[80757],{45317:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=t(85893),a=t(11151);const s={displayed_sidebar:"English"},r="CREATE TABLE",o={id:"sql-reference/sql-statements/data-definition/CREATE_TABLE",title:"CREATE TABLE",description:"Description",source:"@site/versioned_docs/version-3.0/sql-reference/sql-statements/data-definition/CREATE_TABLE.md",sourceDirName:"sql-reference/sql-statements/data-definition",slug:"/sql-reference/sql-statements/data-definition/CREATE_TABLE",permalink:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/CREATE_TABLE",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/sql-reference/sql-statements/data-definition/CREATE_TABLE.md",tags:[],version:"3.0",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"CREATE RESOURCE",permalink:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/CREATE_RESOURCE"},next:{title:"CREATE TABLE AS SELECT",permalink:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/CREATE_TABLE_AS_SELECT"}},l={},c=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"column_definition",id:"column_definition",level:3},{value:"index_definition",id:"index_definition",level:3},{value:"ENGINE type",id:"engine-type",level:3},{value:"key_desc",id:"key_desc",level:3},{value:"COMMENT",id:"comment",level:3},{value:"partition_desc",id:"partition_desc",level:3},{value:"Create partitions dynamically",id:"create-partitions-dynamically",level:4},{value:"Create partitions one by one",id:"create-partitions-one-by-one",level:4},{value:"Create multiple partitions in a batch",id:"create-multiple-partitions-in-a-batch",level:4},{value:"distribution_desc",id:"distribution_desc",level:3},{value:"ORDER BY",id:"order-by",level:3},{value:"PROPERTIES",id:"properties",level:3},{value:"Specify initial storage medium, automatic storage cooldown time, replica number",id:"specify-initial-storage-medium-automatic-storage-cooldown-time-replica-number",level:4},{value:"Add bloom filter index for a column",id:"add-bloom-filter-index-for-a-column",level:4},{value:"Use Colocate Join",id:"use-colocate-join",level:4},{value:"Configure dynamic partitions",id:"configure-dynamic-partitions",level:4},{value:"Set data compression algorithm",id:"set-data-compression-algorithm",level:4},{value:"Set write quorum for data loading",id:"set-write-quorum-for-data-loading",level:4},{value:"Specify data writing and replication mode among replicas",id:"specify-data-writing-and-replication-mode-among-replicas",level:4},{value:"Create rollup in bulk",id:"create-rollup-in-bulk",level:4},{value:"Define Unique Key constraints and Foreign Key constraints for View Delta Join query rewrite",id:"define-unique-key-constraints-and-foreign-key-constraints-for-view-delta-join-query-rewrite",level:4},{value:"Create cloud-native tables for StarRocks Shared-data cluster",id:"create-cloud-native-tables-for-starrocks-shared-data-cluster",level:4},{value:"Examples",id:"examples",level:2},{value:"Create an Aggregate table that uses Hash bucketing and columnar storage",id:"create-an-aggregate-table-that-uses-hash-bucketing-and-columnar-storage",level:3},{value:"Create an Aggregate table and set the storage medium and cooldown time",id:"create-an-aggregate-table-and-set-the-storage-medium-and-cooldown-time",level:3},{value:"Create a Duplicate Key table that uses Range partition, Hash bucketing, and column-based storage, and set the storage medium and cooldown time",id:"create-a-duplicate-key-table-that-uses-range-partition-hash-bucketing-and-column-based-storage-and-set-the-storage-medium-and-cooldown-time",level:3},{value:"Create a MySQL external table",id:"create-a-mysql-external-table",level:3},{value:"Create a table that contains HLL columns",id:"create-a-table-that-contains-hll-columns",level:3},{value:"Create a table containing BITMAP_UNION aggregation type",id:"create-a-table-containing-bitmap_union-aggregation-type",level:3},{value:"Create two tables that support Colocate Join",id:"create-two-tables-that-support-colocate-join",level:3},{value:"Create a table with bitmap index",id:"create-a-table-with-bitmap-index",level:3},{value:"Create a dynamic partition table",id:"create-a-dynamic-partition-table",level:3},{value:"Create a table where multiple partitions are created in a batch, and an integer type column is specified as partitioning column",id:"create-a-table-where-multiple-partitions-are-created-in-a-batch-and-an-integer-type-column-is-specified-as-partitioning-column",level:3},{value:"Create a Hive external table",id:"create-a-hive-external-table",level:3},{value:"Create a Primary Key table and specify the sort key",id:"create-a-primary-key-table-and-specify-the-sort-key",level:3},{value:"References",id:"references",level:2}];function d(e){const n=Object.assign({h1:"h1",h2:"h2",p:"p",blockquote:"blockquote",strong:"strong",pre:"pre",code:"code",h3:"h3",ul:"ul",li:"li",a:"a",h4:"h4",div:"div",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"create-table",children:"CREATE TABLE"}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"Creates a new table in StarRocks."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,i.jsx)(n.p,{children:"This operation requires the CREATE TABLE privilege on the destination database."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:'CREATE [EXTERNAL] TABLE [IF NOT EXISTS] [database.]table_name\n(column_definition1[, column_definition2, ...]\n[, index_definition1[, index_definition12,]])\n[ENGINE = [olap|mysql|elasticsearch|hive|hudi|iceberg|jdbc]]\n[key_desc]\n[COMMENT "table comment"]\n[partition_desc]\ndistribution_desc\n[rollup_index]\n[ORDER BY (column_definition1,...)]\n[PROPERTIES ("key"="value", ...)]\n[BROKER PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.h3,{id:"column_definition",children:"column_definition"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'col_name col_type [agg_type] [NULL | NOT NULL] [DEFAULT "default_value"] [AUTO_INCREMENT]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"col_name"}),": Column name."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"col_type"}),": Column type. Specific column information, such as types and ranges:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"TINYINT (1 byte): Ranges from -2^7 + 1 to 2^7 - 1."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"SMALLINT (2 bytes): Ranges from -2^15 + 1 to 2^15 - 1."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"INT (4 bytes): Ranges from -2^31 + 1 to 2^31 - 1."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"BIGINT (8 bytes): Ranges from -2^63 + 1 to 2^63 - 1."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"LARGEINT (16 bytes): Ranges from -2^127 + 1 to 2^127 - 1."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"FLOAT (4 bytes): Supports scientific notation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"DOUBLE (8 bytes): Supports scientific notation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"DECIMAL[(precision, scale)] (16 bytes)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Default value: DECIMAL(10, 0)"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"precision: 1 ~ 38"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"scale: 0 ~ precision"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Integer part: precision - scale"}),"\n",(0,i.jsx)(n.p,{children:"Scientific notation is not supported."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"DATE (3 bytes): Ranges from 0000-01-01 to 9999-12-31."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"DATETIME (8 bytes): Ranges from 0000-01-01 00:00:00 to 9999-12-31 23:59:59."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"CHAR[(length)]: Fixed length string. Range: 1 ~ 255. Default value: 1."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["VARCHAR[(length)]: A variable-length string. The default value is 1. Unit: bytes. In versions earlier than StarRocks 2.1, the value range of ",(0,i.jsx)(n.code,{children:"length"})," is 1\u201365533. [Preview] In StarRocks 2.1 and later versions, the value range of ",(0,i.jsx)(n.code,{children:"length"})," is 1\u20131048576."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["HLL (1~16385 bytes): For HLL type, there's no need to specify length or default value. The length will be controlled within the system according to data aggregation. HLL column can only be queried or used by ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/aggregate-functions/hll_union_agg",children:"hll_union_agg"}),", ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/scalar-functions/hll_cardinality",children:"Hll_cardinality"}),", and ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/aggregate-functions/hll_hash",children:"hll_hash"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"BITMAP: Bitmap type does not require specified length or default value. It represents a set of unsigned bigint numbers. The largest element could be up to 2^64 - 1."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"agg_type"}),": aggregation type. If not specified, this column is key column.\nIf specified, it is value column. The aggregation types supported are as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SUM, MAX, MIN, REPLACE"}),"\n",(0,i.jsx)(n.li,{children:"HLL_UNION (only for HLL type)"}),"\n",(0,i.jsx)(n.li,{children:"BITMAP_UNION(only for BITMAP)"}),"\n",(0,i.jsx)(n.li,{children:"REPLACE_IF_NOT_NULL: This means the imported data will only be replaced when it is of non-null value. If it is of null value, StarRocks will retain the original value."}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"NOTE"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When the column of aggregation type BITMAP_UNION is imported, its original data types must be TINYINT, SMALLINT, INT, and BIGINT."}),"\n",(0,i.jsx)(n.li,{children:"If NOT NULL is specified by REPLACE_IF_NOT_NULL column when the table was created, StarRocks will still convert the data to NULL without sending an error report to the user. With this, the user can import selected columns."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This aggregation type applies ONLY to the Aggregate table whose key_desc type is AGGREGATE KEY."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NULL | NOT NULL"}),": Whether the column is allowed to be ",(0,i.jsx)(n.code,{children:"NULL"}),". By default, ",(0,i.jsx)(n.code,{children:"NULL"})," is specified for all columns in a table that uses the Duplicate Key, Aggregate, or Unique Key table. In a table that uses the Primary Key table, by default, value columns are specified with ",(0,i.jsx)(n.code,{children:"NULL"}),", whereas key columns are specified with ",(0,i.jsx)(n.code,{children:"NOT NULL"}),". If ",(0,i.jsx)(n.code,{children:"NULL"})," values are included in the raw data, present them with ",(0,i.jsx)(n.code,{children:"\\N"}),". StarRocks treats ",(0,i.jsx)(n.code,{children:"\\N"})," as ",(0,i.jsx)(n.code,{children:"NULL"})," during data loading."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:'DEFAULT "default_value"'}),": the default value of a column. When you load data into StarRocks, if the source field mapped onto the column is empty, StarRocks automatically fills the default value in the column. You can specify a default value in one of the following ways:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"DEFAULT current_timestamp"}),": Use the current time as the default value. For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/date-time-functions/current_timestamp",children:"current_timestamp()"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["DEFAULT ",(0,i.jsx)(n.code,{children:"<default_value>"})]}),": Use a given value of the column data type as the default value. For example, if the data type of the column is VARCHAR, you can specify a VARCHAR string, such as beijing, as the default value, as presented in ",(0,i.jsx)(n.code,{children:'DEFAULT "beijing"'}),". Note that default values cannot be any of the following types: ARRAY, BITMAP, JSON, HLL, and BOOLEAN."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"DEFAULT (<expr>)"}),": Use the result returned by a given function as the default value. Only the ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/utility-functions/uuid",children:"uuid()"})," and ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/utility-functions/uuid_numeric",children:"uuid_numeric()"})," expressions are supported."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"AUTO_INCREMENT"}),": specifies an ",(0,i.jsx)(n.code,{children:"AUTO_INCREMENT"})," column. The data types of ",(0,i.jsx)(n.code,{children:"AUTO_INCREMENT"})," columns must be BIGINT. Auto-incremented IDs start from 1 and increase at a step of 1. For more information about ",(0,i.jsx)(n.code,{children:"AUTO_INCREMENT"})," columns, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/auto_increment",children:"AUTO_INCREMENT"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"index_definition",children:"index_definition"}),"\n",(0,i.jsxs)(n.p,{children:["You can only create bitmap indexes when you create tables. For more information about parameter descriptions and usage notes, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/using_starrocks/Bitmap_index#create-a-bitmap-index",children:"Bitmap indexing"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"INDEX index_name (col_name[, col_name, ...]) [USING BITMAP] COMMENT 'xxxxxx'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"engine-type",children:"ENGINE type"}),"\n",(0,i.jsx)(n.p,{children:"Default value: olap. If this parameter is not specified, an OLAP table (StarRocks native table) is created by default."}),"\n",(0,i.jsxs)(n.p,{children:["Optional value: mysql, elasticsearch, hive, jdbc (2.3 and later), iceberg, and hudi (2.2 and later). If you want to create an external table to query external data sources, specify ",(0,i.jsx)(n.code,{children:"CREATE EXTERNAL TABLE"})," and set ",(0,i.jsx)(n.code,{children:"ENGINE"})," to any of these values. You can refer to ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/data_source/External_table",children:"External table"})," for more information."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Since v3.0, we recommend that you use catalogs to query data from Hive, Iceberg, Hudi, and JDBC data sources. External tables are deprecated. For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/data_source/catalog/hive_catalog",children:"Hive catalog"}),", ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/data_source/catalog/iceberg_catalog",children:"Iceberg catalog"}),", ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/data_source/catalog/hudi_catalog",children:"Hudi catalog"}),", and ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/data_source/catalog/jdbc_catalog",children:"JDBC catalog"}),"."]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For MySQL, specify the following properties:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:'PROPERTIES (\n    "host" = "mysql_server_host",\n    "port" = "mysql_server_port",\n    "user" = "your_user_name",\n    "password" = "your_password",\n    "database" = "database_name",\n    "table" = "table_name"\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsx)(n.p,{children:'"table_name" in MySQL should indicate the real table name. In contrast, "table_name" in CREATE TABLE statement indicates the name of this mysql table on StarRocks. They can either be different or the same.'}),"\n",(0,i.jsx)(n.p,{children:"The aim of creating MySQL tables in StarRocks is to access MySQL database. StarRocks itself does not maintain or store any MySQL data."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For Elasticsearch, specify the following properties:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:'PROPERTIES (\n\n"hosts" = "http://192.168.0.1:8200,http://192.168.0.2:8200",\n"user" = "root",\n"password" = "root",\n"index" = "tindex",\n"type" = "doc"\n)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hosts"}),": the URL that is used to connect your Elasticsearch cluster. You can specify one or more URLs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"user"}),": the account of the root user that is used to log in to your Elasticsearch cluster for which basic authentication is enabled."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"password"}),": the password of the preceding root account."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"index"}),": the index of the StarRocks table in your Elasticsearch cluster. The index name is the same as the StarRocks table name. You can set this parameter to the alias of the StarRocks table."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"type"}),": the type of index. The default value is ",(0,i.jsx)(n.code,{children:"doc"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For Hive, specify the following properties:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:'PROPERTIES (\n\n    "database" = "hive_db_name",\n    "table" = "hive_table_name",\n    "hive.metastore.uris" = "thrift://127.0.0.1:9083"\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here, database is the name of the corresponding database in Hive table. Table is the name of Hive table. hive.metastore.uris is the server address."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For JDBC, specify the following properties:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:'PROPERTIES (\n"resource"="jdbc0",\n"table"="dest_tbl"\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resource"})," is the JDBC resource name and ",(0,i.jsx)(n.code,{children:"table"})," is the destination table."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For Iceberg, specify the following properties:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:' PROPERTIES (\n "resource" = "iceberg0", \n "database" = "iceberg", \n "table" = "iceberg_table"\n )\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resource"})," is the Iceberg resource name. ",(0,i.jsx)(n.code,{children:"database"})," is the Iceberg database. ",(0,i.jsx)(n.code,{children:"table"})," is the Iceberg table."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For Hudi, specify the following properties:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:'  PROPERTIES (\n  "resource" = "hudi0", \n  "database" = "hudi", \n  "table" = "hudi_table" \n  )\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key_desc",children:"key_desc"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"key_type(k1[,k2 ...])\n"})}),"\n",(0,i.jsx)(n.p,{children:"Data is sequenced in specified key columns and has different attributes for different key types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"AGGREGATE KEY: Identical content in key columns will be aggregated into value columns according to the specified aggregation type. It usually applies to business scenarios such as financial statements and multi-dimensional analysis."}),"\n",(0,i.jsx)(n.li,{children:"UNIQUE KEY/PRIMARY KEY: Identical content in key columns will be replaced in value columns according to the import sequence. It can be applied to make addition, deletion, modification and query on key columns."}),"\n",(0,i.jsxs)(n.li,{children:["DUPLICATE KEY: Identical content in key columns, which also exists in StarRocks at the same time. It can be used to store detailed data or data with no aggregation attributes. ",(0,i.jsx)(n.strong,{children:"DUPLICATE KEY is the default type. Data will be sequenced according to key columns."})]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,i.jsx)(n.p,{children:"Value columns do not need to specify aggregation types when other key_type is used to create tables with the exception of AGGREGATE KEY."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"comment",children:"COMMENT"}),"\n",(0,i.jsxs)(n.p,{children:["You can add a table comment when you create a table, optional. Note that COMMENT must be placed after ",(0,i.jsx)(n.code,{children:"key_desc"}),". Otherwise, the table cannot be created."]}),"\n",(0,i.jsx)(n.h3,{id:"partition_desc",children:"partition_desc"}),"\n",(0,i.jsx)(n.p,{children:"Partition description can be used in the following ways:"}),"\n",(0,i.jsx)(n.h4,{id:"create-partitions-dynamically",children:"Create partitions dynamically"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/doc/docs/3.0/table_design/dynamic_partitioning",children:"Dynamic partitioning"})," provides a time-to-live (TTL) management for partitions. StarRocks automatically creates new partitions in advance and removes expired partitions to ensure data freshness. To enable this feature, you can configure Dynamic partitioning related properties at table creation."]}),"\n",(0,i.jsx)(n.h4,{id:"create-partitions-one-by-one",children:"Create partitions one by one"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Specify only the upper bound for a partition"})}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'PARTITION BY RANGE ( <partitioning_column1> [, <partitioning_column2>, ... ] )\n  PARTITION <partition1_name> VALUES LESS THAN ("<upper_bound_for_partitioning_column1>" [ , "<upper_bound_for_partitioning_column2>", ... ] )\n  [ ,\n  PARTITION <partition2_name> VALUES LESS THAN ("<upper_bound_for_partitioning_column1>" [ , "<upper_bound_for_partitioning_column2>", ... ] )\n  , ... ] \n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsx)(n.p,{children:"Please use specified key columns and specified value ranges for partitioning."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Partition name only supports [A-z0-9_]"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Columns in Range partition only support the following types: TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE, and DATETIME."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Partitions are left closed and right open. The left boundary of the first partition is of minimum value."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"NULL value is stored only in partitions that contain minimum values. When the partition containing the minimum value is deleted, NULL values can no longer be imported."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Partition columns can either be single columns or multiple columns. The partition values are the default minimum values."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When only one column is specified as the partitioning column, you can set ",(0,i.jsx)(n.code,{children:"MAXVALUE"})," as the upper bound for the partitioning column of the most recent partition."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PARTITION BY RANGE (pay_dt) (\n  PARTITION p1 VALUES LESS THAN ("20210102"),\n  PARTITION p2 VALUES LESS THAN ("20210103"),\n  PARTITION p3 VALUES LESS THAN MAXVALUE\n)\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Please note:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Partitions are often used for managing data related to time."}),"\n",(0,i.jsx)(n.li,{children:"When data backtracking is needed, you may want to consider emptying the first partition for adding partitions later when necessary."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Specify both the lower and upper bounds for a partition"})}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PARTITION BY RANGE ( <partitioning_column1> [, <partitioning_column2>, ... ] )\n(\n    PARTITION <partition_name1> VALUES [( "<lower_bound_for_partitioning_column1>" [ , "<lower_bound_for_partitioning_column2>", ... ] ), ( "<upper_bound_for_partitioning_column1?" [ , "<upper_bound_for_partitioning_column2>", ... ] ) ) \n    [,\n    PARTITION <partition_name2> VALUES [( "<lower_bound_for_partitioning_column1>" [ , "<lower_bound_for_partitioning_column2>", ... ] ), ( "<upper_bound_for_partitioning_column1>" [ , "<upper_bound_for_partitioning_column2>", ... ] ) ) \n    , ...]\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Fixed Range is more flexible than LESS THAN. You can customize the left and right partitions."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Fixed Range is the same as LESS THAN in the other aspects."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When only one column is specified as the partitioning column, you can set ",(0,i.jsx)(n.code,{children:"MAXVALUE"})," as the upper bound for the partitioning column of the most recent partition."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PARTITION BY RANGE (pay_dt) (\n  PARTITION p202101 VALUES [("20210101"), ("20210201")),\n  PARTITION p202102 VALUES [("20210201"), ("20210301")),\n  PARTITION p202103 VALUES [("20210301"), (MAXVALUE))\n)\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"create-multiple-partitions-in-a-batch",children:"Create multiple partitions in a batch"}),"\n",(0,i.jsx)(n.p,{children:"Syntax"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the partitioning column is of a date type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'PARTITION BY RANGE (<partitioning_column>) (\n    START ("<start_date>") END ("<end_date>") EVERY (INTERVAL <N> <time_unit>)\n)\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the partitioning column is of an integer type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'PARTITION BY RANGE (<partitioning_column>) (\n    START ("<start_integer>") END ("<end_integer>") EVERY (<partitioning_granularity>)\n)\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Description"}),"\n",(0,i.jsxs)(n.p,{children:["You can specify the start and end values in ",(0,i.jsx)(n.code,{children:"START()"})," and ",(0,i.jsx)(n.code,{children:"END()"})," and the time unit or partitioning granularity in ",(0,i.jsx)(n.code,{children:"EVERY()"})," to create multiple partitions in a batch."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The partitioning column can be of a date or integer type."}),"\n",(0,i.jsxs)(n.li,{children:["If the partitioning column is of a date type, you need to use the ",(0,i.jsx)(n.code,{children:"INTERVAL"})," keyword to specify the time interval. You can specify the time unit as hour (since v3.0), day, week, month, or year. The naming conventions of partitions are the same as those for dynamic partitions."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/table_design/Data_distribution",children:"Data distribution"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"distribution_desc",children:"distribution_desc"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Data in partitions can be subdivided into tablets based on the hash values of the bucketing columns and the number of buckets. We recommend that you choose the column that meets the following two requirements as the bucketing column."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High cardinality column such as ID"}),"\n",(0,i.jsx)(n.li,{children:"Column that is often used as a filter in queries"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If such a column does not exist, you can determine the bucketing column according to the complexity of queries."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the query is complex, we recommend that you select a high cardinality column as the bucketing column to ensure balanced data distribution among buckets and improve cluster resource utilization."}),"\n",(0,i.jsx)(n.li,{children:"If the query is relatively simple, we recommend that you select the column that is often used as the query condition as the bucketing column to improve query efficiency."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If partition data cannot be evenly distributed into each tablet by using one bucketing column, you can choose multiple bucketing columns (at most three). For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/table_design/Data_distribution",children:"Choose bucketing columns"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Precautions"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When you create a table, you must specify the bucketing columns"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"The values of bucketing columns cannot be updated."}),"\n",(0,i.jsx)(n.li,{children:"Bucketing columns cannot be modified after they are specified."}),"\n",(0,i.jsxs)(n.li,{children:["Since StarRocks 2.5, you do not need to set the number of buckets when you create a table. StarRocks automatically sets the number of buckets. If you want to set this parameter, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/table_design/Data_distribution#determine-the-number-of-tablets",children:"Determine the number of tablets"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"order-by",children:"ORDER BY"}),"\n",(0,i.jsxs)(n.p,{children:["Since version 3.0, the primary key and sort key are decoupled in the Primary Key table. The sort key is specified by the ",(0,i.jsx)(n.code,{children:"ORDER BY"})," keyword and can be the permutation and combination of any columns."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NOTICE"})}),"\n",(0,i.jsx)(n.p,{children:"If the sort key is specified, the prefix index is built according to the sort key; if the sort key is not specified, the prefix index is built according to the primary key."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"properties",children:"PROPERTIES"}),"\n",(0,i.jsx)(n.h4,{id:"specify-initial-storage-medium-automatic-storage-cooldown-time-replica-number",children:"Specify initial storage medium, automatic storage cooldown time, replica number"}),"\n",(0,i.jsxs)(n.p,{children:["If the engine type is ",(0,i.jsx)(n.code,{children:"OLAP"}),", you can specify initial storage medium (",(0,i.jsx)(n.code,{children:"storage_medium"}),"), automatic storage cooldown time (",(0,i.jsx)(n.code,{children:"storage_cooldown_time"}),") or time interval (",(0,i.jsx)(n.code,{children:"storage_cooldown_ttl"}),"), and replica number (",(0,i.jsx)(n.code,{children:"replication_num"}),") when you create a table."]}),"\n",(0,i.jsxs)(n.p,{children:["The scope where the properties take effect: If the table has only one partition, the properties belong to the table. If the table is divided into multiple partitions, the properties belong to each partition. And when you need to configure different properties for specified partitions, you can execute ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/ALTER_TABLE",children:"ALTER TABLE ... ADD PARTITION or ALTER TABLE ... MODIFY PARTITION"})," after table creation."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Set initial storage medium and automatic storage cooldown time"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'PROPERTIES (\n    "storage_medium" = "[SSD|HDD]",\n    { "storage_cooldown_ttl" = "<num> { YEAR | MONTH | DAY | HOUR } "\n    | "storage_cooldown_time" = "yyyy-MM-dd HH:mm:ss" }\n)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"storage_medium"}),": the initial storage medium, which can be set to ",(0,i.jsx)(n.code,{children:"SSD"})," or ",(0,i.jsx)(n.code,{children:"HDD"}),". Make sure that the type of storage medium you explicitly specified is consistent with the BE disk types for your StarRocks cluster specified in the BE static parameter ",(0,i.jsx)(n.code,{children:"storage_root_path"}),".",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["If the FE configuration item ",(0,i.jsx)(n.code,{children:"enable_strict_storage_medium_check"})," is set to ",(0,i.jsx)(n.code,{children:"true"}),', the system strictly checks BE disk type when you create a table. If the storage medium you specified in CREATE TABLE is inconsistent with BE disk type, an error "Failed to find enough host in all backends with storage medium is SSD|HDD." is returned and table creation fails. If ',(0,i.jsx)(n.code,{children:"enable_strict_storage_medium_check"})," is set to ",(0,i.jsx)(n.code,{children:"false"}),", the system ignores this error and forcibly creates the table. However, cluster disk space may be unevenly distributed after data is loaded.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["From v2.3.6, v2.4.2, v2.5.1, and v3.0 onwards, the system automatically infers storage medium based on BE disk type if ",(0,i.jsx)(n.code,{children:"storage_medium"})," is not explicitly specified.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The system automatically sets this parameter to SSD in the following scenarios:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The disk types reported by BEs (",(0,i.jsx)(n.code,{children:"storage_root_path"}),") contain only SSD."]}),"\n",(0,i.jsxs)(n.li,{children:["The disk types reported by BEs (",(0,i.jsx)(n.code,{children:"storage_root_path"}),") contain both SSD and HDD. Note that from v2.3.10, v2.4.5, v2.5.4, and v3.0 onwards, the system sets ",(0,i.jsx)(n.code,{children:"storage_medium"})," to SSD when ",(0,i.jsx)(n.code,{children:"storage_root_path"})," reported by BEs contain both SSD and HDD and the property ",(0,i.jsx)(n.code,{children:"storage_cooldown_time"})," is specified."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The system automatically sets this parameter to HDD in the following scenarios:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The disk types reported by BEs (",(0,i.jsx)(n.code,{children:"storage_root_path"}),") contain only HDD."]}),"\n",(0,i.jsxs)(n.li,{children:["From 2.3.10, 2.4.5, 2.5.4, and 3.0 onwards,  the system sets ",(0,i.jsx)(n.code,{children:"storage_medium"})," to HDD when ",(0,i.jsx)(n.code,{children:"storage_root_path"})," reported by BEs contain both SSD and HDD and the property ",(0,i.jsx)(n.code,{children:"storage_cooldown_time"})," is not specified."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"storage_cooldown_ttl"})," or ",(0,i.jsx)(n.code,{children:"storage_cooldown_time"}),": the automatic storage cooldown time or time interval. Automatic storage cooldown refers to automatically migrate data from SSD to HDD. This feature is only effective when the initial storage medium is SSD."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameter"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"storage_cooldown_ttl"}),"\uff1athe ",(0,i.jsx)(n.strong,{children:"time interval"})," of automatic storage cooldown for the partitions in this table. If you need to retain the most recent partitions on SSD and automatically cool down older partitions to HDD after a certain time interval, you can use this parameter. The automatic storage cooldown time for each partition is calculated using the value of this parameter plus the upper time bound of the partition."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The supported values are ",(0,i.jsx)(n.code,{children:"<num> YEAR"}),", ",(0,i.jsx)(n.code,{children:"<num> MONTH"}),", ",(0,i.jsx)(n.code,{children:"<num> DAY"}),", and ",(0,i.jsx)(n.code,{children:"<num> HOUR"}),". ",(0,i.jsx)(n.code,{children:"<num>"})," is a non-negative integer. The default value is null, indicating that storage cooldown is not automatically performed."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, you specify the value as ",(0,i.jsx)(n.code,{children:'"storage_cooldown_ttl"="1 DAY"'})," when creating the table, and the partition ",(0,i.jsx)(n.code,{children:"p20230801"})," with a range of ",(0,i.jsx)(n.code,{children:"[2023-08-01 00:00:00,2023-08-02 00:00:00)"})," exists. The automatic storage cooldown time for this partition is ",(0,i.jsx)(n.code,{children:"2023-08-03 00:00:00"}),", which is ",(0,i.jsx)(n.code,{children:"2023-08-02 00:00:00 + 1 DAY"}),". If you specify the value as ",(0,i.jsx)(n.code,{children:'"storage_cooldown_ttl"="0 DAY"'})," when creating the table, the automatic storage cooldown time for this partition is ",(0,i.jsx)(n.code,{children:"2023-08-02 00:00:00"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"storage_cooldown_time"}),": the automatic storage cooldown time (",(0,i.jsx)(n.strong,{children:"absolute time"}),') when the table is cooled down from SSD to HDD. The specified time needs to be later than the current time. Format: "yyyy-MM-dd HH:mm',(0,i.jsx)(n.div,{}),'". When you need to configure different properties for specified partitions, you can execute ',(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/ALTER_TABLE",children:"ALTER TABLE ... ADD PARTITION or ALTER TABLE ... MODIFY PARTITION"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usages"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The comparison between the parameters related to automatic storage cooldown is as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"storage_cooldown_ttl"}),": A table property that specifies the time interval of automatic storage cooldown for partitions in the table. The system automatically cools down a partition at the time ",(0,i.jsx)(n.code,{children:"the value of this parameter plus the upper time bound of the partition"}),". So automatic storage cooldown is performed at the partition granularity, which is more flexible."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"storage_cooldown_time"}),": A table property that specifies the automatic storage cooldown time (",(0,i.jsx)(n.strong,{children:"absolute time"}),") for this table. Also, you can configure different properties for specified partitions after table creation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"storage_cooldown_second"}),": A static FE parameter that specifies the automatic storage cooldown latency for all tables within the cluster."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The table property ",(0,i.jsx)(n.code,{children:"storage_cooldown_ttl"})," or ",(0,i.jsx)(n.code,{children:"storage_cooldown_time"})," takes precedence over the FE static parameter ",(0,i.jsx)(n.code,{children:"storage_cooldown_second"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When configuring these parameters, you need to specify ",(0,i.jsx)(n.code,{children:'"storage_medium = "SSD"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If you do not configure these parameters, automatic storage cooldown is not be automatically performed."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Execute ",(0,i.jsx)(n.code,{children:"SHOW PARTITIONS FROM <table_name>"})," to view the automatic storage cooldown time for each partition."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Limit"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Expression and List partitioning are not supported."}),"\n",(0,i.jsx)(n.li,{children:"The partition column need to be of date type."}),"\n",(0,i.jsx)(n.li,{children:"Multiple partition columns are not supported."}),"\n",(0,i.jsx)(n.li,{children:"Primary Key tables are not supported."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Set the number of replicas for each tablet in partitions"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"replication_num"}),": number of replicas for each table in the partitions. Default number: ",(0,i.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'PROPERTIES (\n    "replication_num" = "<num>"\n)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"add-bloom-filter-index-for-a-column",children:"Add bloom filter index for a column"}),"\n",(0,i.jsx)(n.p,{children:"If the Engine type is olap, you can specify a column to adopt bloom filter indexes."}),"\n",(0,i.jsx)(n.p,{children:"The following limits apply when you use bloom filter index:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You can create bloom filter indexes for all columns of a Duplicate Key or Primary Key table. For an Aggregate table or Unique Key table, you can only create bloom filter indexes for key columns."}),"\n",(0,i.jsx)(n.li,{children:"TINYINT, FLOAT, DOUBLE, and DECIMAL columns do not support creating bloom filter indexes."}),"\n",(0,i.jsxs)(n.li,{children:["Bloom filter indexes can only improve the performance of queries that contain the ",(0,i.jsx)(n.code,{children:"in"})," and ",(0,i.jsx)(n.code,{children:"="})," operators, such as ",(0,i.jsx)(n.code,{children:"Select xxx from table where x in {}"})," and ",(0,i.jsx)(n.code,{children:"Select xxx from table where column = xxx"}),". More discrete values in this column will result in more precise queries."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/using_starrocks/Bloomfilter_index",children:"Bloom filter indexing"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PROPERTIES (\n    "bloom_filter_columns"="k1,k2,k3"\n)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"use-colocate-join",children:"Use Colocate Join"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to use Colocate Join attributes, specify it in ",(0,i.jsx)(n.code,{children:"properties"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PROPERTIES (\n    "colocate_with"="table1"\n)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"configure-dynamic-partitions",children:"Configure dynamic partitions"}),"\n",(0,i.jsx)(n.p,{children:"If you want to use dynamic partition attributes, please specify it in properties."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PROPERTIES (\n\n    "dynamic_partition.enable" = "true|false",\n    "dynamic_partition.time_unit" = "DAY|WEEK|MONTH",\n    "dynamic_partition.start" = "${integer_value}",\n    "dynamic_partition.end" = "${integer_value}",\n    "dynamic_partition.prefix" = "${string_value}",\n    "dynamic_partition.buckets" = "${integer_value}"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"PROPERTIES"})})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Required"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dynamic_partition.enable"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["Whether to enable dynamic partitioning. Valid values: ",(0,i.jsx)(n.code,{children:"TRUE"})," and ",(0,i.jsx)(n.code,{children:"FALSE"}),". Default value: ",(0,i.jsx)(n.code,{children:"TRUE"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dynamic_partition.time_unit"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsxs)(n.td,{children:["The time granularity for dynamically created  partitions. It is a required parameter. Valid values: ",(0,i.jsx)(n.code,{children:"DAY"}),", ",(0,i.jsx)(n.code,{children:"WEEK"}),", and ",(0,i.jsx)(n.code,{children:"MONTH"}),". The time granularity determines the suffix format for dynamically created partitions.",(0,i.jsx)("br",{}),"  - If the value is ",(0,i.jsx)(n.code,{children:"DAY"}),", the suffix format for dynamically created partitions is ",(0,i.jsx)(n.code,{children:"yyyyMMdd"}),". An example partition name suffix is ",(0,i.jsx)(n.code,{children:"20200321"}),".",(0,i.jsx)("br",{}),"  - If the value is ",(0,i.jsx)(n.code,{children:"WEEK"}),", the suffix format for dynamically created partitions is ",(0,i.jsx)(n.code,{children:"yyyy_ww"}),", for example ",(0,i.jsx)(n.code,{children:"2020_13"})," for the 13th week of 2020.",(0,i.jsx)("br",{}),"  - If the value is ",(0,i.jsx)(n.code,{children:"MONTH"}),", the suffix format for dynamically created partitions is ",(0,i.jsx)(n.code,{children:"yyyyMM"}),", for example ",(0,i.jsx)(n.code,{children:"202003"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dynamic_partition.start"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The starting offset of dynamic partitioning. The value of this parameter must be a negative integer. The partitions before this offset will be deleted based on the current day, week, or month which is determined by ",(0,i.jsx)(n.code,{children:"dynamic_partition.time_unit"}),". The default value is ",(0,i.jsx)(n.code,{children:"Integer.MIN_VALUE"}),", namely, -2147483648, which means that historical partitions will not be deleted."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dynamic_partition.end"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"The end offset of dynamic partitioning. The value of this parameter must be a positive integer. The partitions from the current day, week, or month to the end offset will be created in advance."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dynamic_partition.prefix"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The prefix added to the names of dynamic partitions. Default value: ",(0,i.jsx)(n.code,{children:"p"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dynamic_partition.buckets"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The number of buckets per dynamic partition. The default value is the same as the number of buckets determined by the reserved word ",(0,i.jsx)(n.code,{children:"BUCKETS"})," or automatically set by StarRocks."]})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"set-data-compression-algorithm",children:"Set data compression algorithm"}),"\n",(0,i.jsxs)(n.p,{children:["You can specify a data compression algorithm for a table by adding property ",(0,i.jsx)(n.code,{children:"compression"})," when you create a table."]}),"\n",(0,i.jsxs)(n.p,{children:["The valid values of ",(0,i.jsx)(n.code,{children:"compression"})," are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"LZ4"}),": the LZ4 algorithm."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ZSTD"}),": the Zstandard algorithm."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ZLIB"}),": the zlib algorithm."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SNAPPY"}),": the Snappy algorithm."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more information about how to choose a suitable data compression algorithm, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/table_design/data_compression",children:"Data compression"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"set-write-quorum-for-data-loading",children:"Set write quorum for data loading"}),"\n",(0,i.jsxs)(n.p,{children:["If your StarRocks cluster has multiple data replicas, you can set different write quorum for tables, that is, how many replicas are required to return loading success before StarRocks can determine the loading task is successful. You can specify write quorum by adding the property ",(0,i.jsx)(n.code,{children:"write_quorum"})," when you create a table. This property is supported from v2.5."]}),"\n",(0,i.jsxs)(n.p,{children:["The valid values of ",(0,i.jsx)(n.code,{children:"write_quorum"})," are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MAJORITY"}),": Default value. When the ",(0,i.jsx)(n.strong,{children:"majority"})," of data replicas return loading success, StarRocks returns loading task success. Otherwise, StarRocks returns loading task failed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ONE"}),": When ",(0,i.jsx)(n.strong,{children:"one"})," of the data replicas returns loading success, StarRocks returns loading task success. Otherwise, StarRocks returns loading task failed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ALL"}),": When ",(0,i.jsx)(n.strong,{children:"all"})," of the data replicas return loading success, StarRocks returns loading task success. Otherwise, StarRocks returns loading task failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CAUTION"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Setting a low write quorum for loading increases the risk of data inaccessibility and even loss. For example, you load data into a table with one write quorum in a StarRocks cluster of two replicas, and the data was successfully loaded into only one replica. Despite that StarRocks determines the loading task succeeded, there is only one surviving replica of the data. If the server which stores the tablets of loaded data goes down, the data in these tablets becomes inaccessible. And if the disk of the server is damaged, the data is lost."}),"\n",(0,i.jsx)(n.li,{children:"StarRocks returns the loading task status only after all data replicas have returned the status. StarRocks will not return the loading task status when there are replicas whose loading status is unknown. In a replica, loading timeout is also considered as loading failed."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"specify-data-writing-and-replication-mode-among-replicas",children:"Specify data writing and replication mode among replicas"}),"\n",(0,i.jsxs)(n.p,{children:["If your StarRocks cluster has multiple data replicas, you can specify the ",(0,i.jsx)(n.code,{children:"replicated_storage"})," parameter in ",(0,i.jsx)(n.code,{children:"PROPERTIES"})," to configure the data writing and replication mode among replicas."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"true"}),' (default in v3.0 and later) indicates "single leader replication", which means data is written only to the primary replica. Other replicas synchronize data from the primary replica. This mode significantly reduces CPU cost caused by data writing to multiple replicas. It is supported from v2.5.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"false"}),' (default in v2.5) indicates "leaderless replication", which means data is directly written to multiple replicas, without differentiating primary and secondary replicas. The CPU cost is multiplied by the number of replicas.']}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In most cases, using the default value gains better data writing performance. If you want to change the data writing and replication mode among replicas, run the ALTER TABLE command. Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'    ALTER TABLE example_db.my_table\n    SET ("replicated_storage" = "false");\n'})}),"\n",(0,i.jsx)(n.h4,{id:"create-rollup-in-bulk",children:"Create rollup in bulk"}),"\n",(0,i.jsx)(n.p,{children:"You can create rollup in bulk when you create a table."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'ROLLUP (rollup_name (column_name1, column_name2, ...)\n[FROM from_index_name]\n[PROPERTIES ("key"="value", ...)],...)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"define-unique-key-constraints-and-foreign-key-constraints-for-view-delta-join-query-rewrite",children:"Define Unique Key constraints and Foreign Key constraints for View Delta Join query rewrite"}),"\n",(0,i.jsxs)(n.p,{children:["To enable query rewrite in the View Delta Join scenario, you must define the Unique Key constraints ",(0,i.jsx)(n.code,{children:"unique_constraints"})," and Foreign Key constraints ",(0,i.jsx)(n.code,{children:"foreign_key_constraints"})," for the table to be joined in the Delta Join. See ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/using_starrocks/Materialized_view#rewrite-queries-in-view-delta-join-scenario",children:"Asynchronous materialized view - Rewrite queries in View Delta Join scenario"})," for further information."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PROPERTIES (\n    "unique_constraints" = "<unique_key>[, ...]",\n    "foreign_key_constraints" = "\n    (<child_column>[, ...]) \n    REFERENCES \n    [catalog_name].[database_name].<parent_table_name>(<parent_column>[, ...])\n    [;...]\n    "\n)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"child_column"}),": the Foreign Key of the table. You can define multiple ",(0,i.jsx)(n.code,{children:"child_column"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"catalog_name"}),": the name of the catalog where the table to join resides. The default catalog is used if this parameter is not specified."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"database_name"}),": the name of the database where the table to join resides. The current database is used if this parameter is not specified."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parent_table_name"}),": the name of the table to join."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parent_column"}),": the column to be joined. They must be the Primary Keys or Unique Keys of the corresponding tables."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CAUTION"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The Unique Key constraints and Foreign Key constraints are only used for query rewrite. The Foreign Key constraint checks are not guaranteed when data is loaded into the table. You must ensure the data loaded into the table meets the constraints."}),"\n",(0,i.jsxs)(n.li,{children:["The primary keys of a Primary Key table or the unique keys of a Unique Key table are, by default, the corresponding ",(0,i.jsx)(n.code,{children:"unique_constraints"}),". You do not need to set it manually."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"child_column"})," in a table's ",(0,i.jsx)(n.code,{children:"foreign_key_constraints"})," must be referenced to a ",(0,i.jsx)(n.code,{children:"unique_key"})," in another table's ",(0,i.jsx)(n.code,{children:"unique_constraints"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The number of ",(0,i.jsx)(n.code,{children:"child_column"})," and ",(0,i.jsx)(n.code,{children:"parent_column"})," must agree."]}),"\n",(0,i.jsxs)(n.li,{children:["The data types of the ",(0,i.jsx)(n.code,{children:"child_column"})," and the corresponding ",(0,i.jsx)(n.code,{children:"parent_column"})," must match."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"create-cloud-native-tables-for-starrocks-shared-data-cluster",children:"Create cloud-native tables for StarRocks Shared-data cluster"}),"\n",(0,i.jsxs)(n.p,{children:["To ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/deployment/deploy_shared_data#use-your-shared-data-starrocks-cluster",children:"use your StarRocks Shared-data cluster"}),", you must create cloud-native tables with the following properties:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'PROPERTIES (\n    "enable_storage_cache" = "{ true | false }",\n    "storage_cache_ttl" = "<integer_value>",\n    "enable_async_write_back" = "{ true | false }"\n)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enable_storage_cache"}),": Whether to enable the local disk cache. Default: ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When this property is set to ",(0,i.jsx)(n.code,{children:"true"}),", the data to be loaded is simultaneously written into the object storage and the local disk (as the cache for query acceleration)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When this property is set to ",(0,i.jsx)(n.code,{children:"false"}),", the data is loaded only into the object storage."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,i.jsxs)(n.p,{children:["To enable the local disk cache, you must specify the directory of the disk in the BE configuration item ",(0,i.jsx)(n.code,{children:"storage_root_path"}),". For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/administration/Configuration#be-configuration-items",children:"BE Configuration items"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"storage_cache_ttl"}),": The duration for which StarRocks caches the loaded data in the local disk if the local disk cache is enabled. The expired data is deleted from the local disk. If the value is set to ",(0,i.jsx)(n.code,{children:"-1"}),", the cached data does not expire. Default: ",(0,i.jsx)(n.code,{children:"2592000"})," (30 days)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CAUTION"})}),"\n",(0,i.jsxs)(n.p,{children:["If you disabled the local disk cache, you do not need to set this configuration item. Setting this item to a value other than ",(0,i.jsx)(n.code,{children:"0"})," when the local disk cache is disabled will cause unexpected behaviors of StarRocks."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enable_async_write_back"}),": Whether to allow data to be written into object storage asynchronously. Default: ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When this property is set to ",(0,i.jsx)(n.code,{children:"true"}),", the load task returns success as soon as the data is written into the local disk cache, and the data is written into the object storage asynchronously. This allows better loading performance, but it also risks data reliability under potential system failures."]}),"\n",(0,i.jsxs)(n.li,{children:["When this property is set to ",(0,i.jsx)(n.code,{children:"false"}),", the load task returns success only after the data is written into both object storage and the local disk cache. This guarantees higher availability but leads to lower loading performance."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.h3,{id:"create-an-aggregate-table-that-uses-hash-bucketing-and-columnar-storage",children:"Create an Aggregate table that uses Hash bucketing and columnar storage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 CHAR(10) REPLACE,\n    v2 INT SUM\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nCOMMENT "my first starrocks table"\nDISTRIBUTED BY HASH(k1)\nPROPERTIES ("storage_type"="column");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-an-aggregate-table-and-set-the-storage-medium-and-cooldown-time",children:"Create an Aggregate table and set the storage medium and cooldown time"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.table_hash\n(\n    k1 BIGINT,\n    k2 LARGEINT,\n    v1 VARCHAR(2048) REPLACE,\n    v2 SMALLINT SUM DEFAULT "10"\n)\nENGINE=olap\nUNIQUE KEY(k1, k2)\nDISTRIBUTED BY HASH (k1, k2)\nPROPERTIES(\n    "storage_type"="column",\n    "storage_medium" = "SSD",\n    "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.table_hash\n(\n    k1 BIGINT,\n    k2 LARGEINT,\n    v1 VARCHAR(2048) REPLACE,\n    v2 SMALLINT SUM DEFAULT "10"\n)\nENGINE=olap\nPRIMARY KEY(k1, k2)\nDISTRIBUTED BY HASH (k1, k2)\nPROPERTIES(\n    "storage_type"="column",\n    "storage_medium" = "SSD",\n    "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-duplicate-key-table-that-uses-range-partition-hash-bucketing-and-column-based-storage-and-set-the-storage-medium-and-cooldown-time",children:"Create a Duplicate Key table that uses Range partition, Hash bucketing, and column-based storage, and set the storage medium and cooldown time"}),"\n",(0,i.jsx)(n.p,{children:"LESS THAN"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.table_range\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1)\n(\n    PARTITION p1 VALUES LESS THAN ("2014-01-01"),\n    PARTITION p2 VALUES LESS THAN ("2014-06-01"),\n    PARTITION p3 VALUES LESS THAN ("2014-12-01")\n)\nDISTRIBUTED BY HASH(k2)\nPROPERTIES(\n    "storage_medium" = "SSD", \n    "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsx)(n.p,{children:"This statement will create three data partitions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'( {    MIN     },   {"2014-01-01"} )\n[ {"2014-01-01"},   {"2014-06-01"} )\n[ {"2014-06-01"},   {"2014-12-01"} )\n'})}),"\n",(0,i.jsx)(n.p,{children:"Data outside these ranges will be not be loaded."}),"\n",(0,i.jsx)(n.p,{children:"Fixed Range"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE table_range\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1, k2, k3)\n(\n    PARTITION p1 VALUES [("2014-01-01", "10", "200"), ("2014-01-01", "20", "300")),\n    PARTITION p2 VALUES [("2014-06-01", "100", "200"), ("2014-07-01", "100", "300"))\n)\nDISTRIBUTED BY HASH(k2)\nPROPERTIES(\n    "storage_medium" = "SSD"\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-mysql-external-table",children:"Create a MySQL external table"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE EXTERNAL TABLE example_db.table_mysql\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    k4 VARCHAR(2048),\n    k5 DATETIME\n)\nENGINE=mysql\nPROPERTIES\n(\n    "host" = "127.0.0.1",\n    "port" = "8239",\n    "user" = "mysql_user",\n    "password" = "mysql_passwd",\n    "database" = "mysql_db_test",\n    "table" = "mysql_table_test"\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-table-that-contains-hll-columns",children:"Create a table that contains HLL columns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.example_table\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 HLL HLL_UNION,\n    v2 HLL HLL_UNION\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1)\nPROPERTIES ("storage_type"="column");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-table-containing-bitmap_union-aggregation-type",children:"Create a table containing BITMAP_UNION aggregation type"}),"\n",(0,i.jsxs)(n.p,{children:["The original data type of ",(0,i.jsx)(n.code,{children:"v1"})," and ",(0,i.jsx)(n.code,{children:"v2"})," columns must be TINYINT, SMALLINT, or INT."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.example_table\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 BITMAP BITMAP_UNION,\n    v2 BITMAP BITMAP_UNION\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1)\nPROPERTIES ("storage_type"="column");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-two-tables-that-support-colocate-join",children:"Create two tables that support Colocate Join"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE `t1` \n(\n     `id` int(11) COMMENT "",\n    `value` varchar(8) COMMENT ""\n) \nENGINE=OLAP\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`)\nPROPERTIES \n(\n    "colocate_with" = "t1"\n);\n\nCREATE TABLE `t2` \n(\n    `id` int(11) COMMENT "",\n    `value` varchar(8) COMMENT ""\n) \nENGINE=OLAP\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`)\nPROPERTIES \n(\n    "colocate_with" = "t1"\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-table-with-bitmap-index",children:"Create a table with bitmap index"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 CHAR(10) REPLACE,\n    v2 INT SUM,\n    INDEX k1_idx (k1) USING BITMAP COMMENT \'xxxxxx\'\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nCOMMENT "my first starrocks table"\nDISTRIBUTED BY HASH(k1)\nPROPERTIES ("storage_type"="column");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-dynamic-partition-table",children:"Create a dynamic partition table"}),"\n",(0,i.jsxs)(n.p,{children:['The dynamic partitioning function must be enabled ("dynamic_partition.enable" = "true") in FE configuration. For more information, see ',(0,i.jsx)(n.a,{href:"#configure-dynamic-partitions",children:"Configure dynamic partitions"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This example creates partitions for the next three days and deletes partitions created three days ago. For example, if today is 2020-01-08, partitions with the following names will be created: p20200108, p20200109, p20200110, p20200111, and their ranges are:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plaintext",children:"[types: [DATE]; keys: [2020-01-08]; \u2025types: [DATE]; keys: [2020-01-09]; )\n[types: [DATE]; keys: [2020-01-09]; \u2025types: [DATE]; keys: [2020-01-10]; )\n[types: [DATE]; keys: [2020-01-10]; \u2025types: [DATE]; keys: [2020-01-11]; )\n[types: [DATE]; keys: [2020-01-11]; \u2025types: [DATE]; keys: [2020-01-12]; )\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1)\n(\n    PARTITION p1 VALUES LESS THAN ("2014-01-01"),\n    PARTITION p2 VALUES LESS THAN ("2014-06-01"),\n    PARTITION p3 VALUES LESS THAN ("2014-12-01")\n)\nDISTRIBUTED BY HASH(k2)\nPROPERTIES(\n    "storage_medium" = "SSD",\n    "dynamic_partition.enable" = "true",\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "10"\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-table-where-multiple-partitions-are-created-in-a-batch-and-an-integer-type-column-is-specified-as-partitioning-column",children:"Create a table where multiple partitions are created in a batch, and an integer type column is specified as partitioning column"}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, the partitioning column ",(0,i.jsx)(n.code,{children:"datekey"})," is of the INT type. All the partitions are created by only one simple partition clause  ",(0,i.jsx)(n.code,{children:'START ("1") END ("5") EVERY (1)'}),". The range of all the partitions starts from ",(0,i.jsx)(n.code,{children:"1"})," and ends at ",(0,i.jsx)(n.code,{children:"5"}),", with a partition granularity of ",(0,i.jsx)(n.code,{children:"1"}),":"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,i.jsxs)(n.p,{children:["The partitioning column values in ",(0,i.jsx)(n.strong,{children:"START()"})," and ",(0,i.jsx)(n.strong,{children:"END()"})," need to be wrapped in quotation marks, while the partition granularity in the ",(0,i.jsx)(n.strong,{children:"EVERY()"})," does not need to be wrapped in quotation marks."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE site_access (\n    datekey INT,\n    site_id INT,\n    city_code SMALLINT,\n    user_name VARCHAR(32),\n    pv BIGINT DEFAULT \'0\'\n)\nENGINE=olap\nDUPLICATE KEY(datekey, site_id, city_code, user_name)\nPARTITION BY RANGE (datekey) (START ("1") END ("5") EVERY (1)\n)\nDISTRIBUTED BY HASH(site_id)\nPROPERTIES ("replication_num" = "3");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-hive-external-table",children:"Create a Hive external table"}),"\n",(0,i.jsxs)(n.p,{children:["Before you create a Hive external table, you must have created a Hive resource and database. For more information, see ",(0,i.jsx)(n.a,{href:"/doc/docs/3.0/data_source/External_table#hive-external-table",children:"External table"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'CREATE EXTERNAL TABLE example_db.table_hive\n(\n    k1 TINYINT,\n    k2 VARCHAR(50),\n    v INT\n)\nENGINE=hive\nPROPERTIES\n(\n    "resource" = "hive0",\n    "database" = "hive_db_name",\n    "table" = "hive_table_name"\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-primary-key-table-and-specify-the-sort-key",children:"Create a Primary Key table and specify the sort key"}),"\n",(0,i.jsxs)(n.p,{children:["Suppose that you need to analyze user behavior in real time from dimensions such as users' address and last active time. When you create a table, you can define the ",(0,i.jsx)(n.code,{children:"user_id"})," column as the primary key and define the combination of the ",(0,i.jsx)(n.code,{children:"address"})," and ",(0,i.jsx)(n.code,{children:"last_active"})," columns as the sort key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'create table users (\n    user_id bigint NOT NULL,\n    name string NOT NULL,\n    email string NULL,\n    address string NULL,\n    age tinyint NULL,\n    sex tinyint NULL,\n    last_active datetime,\n    property0 tinyint NOT NULL,\n    property1 tinyint NOT NULL,\n    property2 tinyint NOT NULL,\n    property3 tinyint NOT NULL\n) \nPRIMARY KEY (`user_id`)\nDISTRIBUTED BY HASH(`user_id`)\nORDER BY(`address`,`last_active`)\nPROPERTIES(\n    "replication_num" = "3",\n    "enable_persistent_index" = "true"\n);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-manipulation/SHOW_CREATE_TABLE",children:"SHOW CREATE TABLE"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-manipulation/SHOW_TABLES",children:"SHOW TABLES"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/USE",children:"USE"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/ALTER_TABLE",children:"ALTER TABLE"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/doc/docs/3.0/sql-reference/sql-statements/data-definition/DROP_TABLE",children:"DROP TABLE"})}),"\n"]})]})}const h=function(e={}){const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(d,e)})):d(e)}},11151:(e,n,t)=>{t.d(n,{Zo:()=>o,ah:()=>s});var i=t(67294);const a=i.createContext({});function s(e){const n=i.useContext(a);return i.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const r={};function o({components:e,children:n,disableParentContext:t}){let o;return o=t?"function"==typeof e?e({}):e||r:s(e),i.createElement(a.Provider,{value:o},n)}}}]);