"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[56943],{87914:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var n=t(85893),i=t(11151);const o={displayed_sidebar:"English"},c="Sort Keys",r={id:"table_design/Sort_key",title:"Sort Keys",description:"How Sort Keys Work",source:"@site/versioned_docs/version-2.0/table_design/Sort_key.md",sourceDirName:"table_design",slug:"/table_design/Sort_key",permalink:"/docs/2.0/table_design/Sort_key",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/table_design/Sort_key.md",tags:[],version:"2.0",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"Materialized View",permalink:"/docs/2.0/table_design/Materialized_view"},next:{title:"Table Design",permalink:"/docs/2.0/table_design/StarRocks_table_design"}},d={},l=[{value:"How Sort Keys Work",id:"how-sort-keys-work",level:2},{value:"How to choose the sort key",id:"how-to-choose-the-sort-key",level:3},{value:"Notes",id:"notes",level:3}];function a(e){const s=Object.assign({h1:"h1",h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre",ol:"ol",li:"li",ul:"ul",h3:"h3"},(0,i.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"sort-keys",children:"Sort Keys"}),"\n",(0,n.jsx)(s.h2,{id:"how-sort-keys-work",children:"How Sort Keys Work"}),"\n",(0,n.jsxs)(s.p,{children:["In StarRocks, data is sorted by the columns which are specified as sort keys to speed up queries. The sort key in the ",(0,n.jsx)(s.strong,{children:"duplicate model"})," is the column specified by ",(0,n.jsx)(s.code,{children:"DUPLICATE KEY"}),". In the ",(0,n.jsx)(s.strong,{children:"aggregation model"}),", the sort key is the column specified by ",(0,n.jsx)(s.code,{children:"AGGREGATE KEY"}),", and the sort key in the ",(0,n.jsx)(s.strong,{children:"update model"})," is the column specified by ",(0,n.jsx)(s.code,{children:"UNIQUE KEY"}),". In the following Figure 5.1, ",(0,n.jsx)(s.code,{children:"site_id"}),", ",(0,n.jsx)(s.code,{children:"city_code"})," are the sort keys  in the table building statement."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-SQL",children:"CREATE TABLE site_access_duplicate\n(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT DEFAULT '0'\n)\nDUPLICATE KEY(site_id, city_code)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n \nCREATE TABLE site_access_aggregate\n(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT SUM DEFAULT '0'\n)\nAGGREGATE KEY(site_id, city_code)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n \nCREATE TABLE site_access_unique\n(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT DEFAULT '0'\n)\nUNIQUE KEY(site_id, city_code)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n"})}),"\n",(0,n.jsx)(s.p,{children:":-: Figure 5.1: Using sort keys for the three table building models"}),"\n",(0,n.jsxs)(s.p,{children:["In Figure 5.1, the data in each table are sorted by ",(0,n.jsx)(s.code,{children:"site_id"})," and ",(0,n.jsx)(s.code,{children:"city_code"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"Notes:"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["In the table building statements, the sort keys must be defined  before the definitions of the other columns. Take the table building statement in Figure 1 as an example, the sort key of the three tables can be ",(0,n.jsx)(s.code,{children:"site_id"}),", ",(0,n.jsx)(s.code,{children:"city_code"}),", or ",(0,n.jsx)(s.code,{children:"site_id"}),", ",(0,n.jsx)(s.code,{children:"city_code"}),", ",(0,n.jsx)(s.code,{children:"user_name"}),", but not ",(0,n.jsx)(s.code,{children:"city_code"}),", ",(0,n.jsx)(s.code,{children:"user_name"}),", or ",(0,n.jsx)(s.code,{children:"site_id"}),", ",(0,n.jsx)(s.code,{children:"city_code"}),", ",(0,n.jsx)(s.code,{children:"pv"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:["The sorting order of the sort keys is determined by the column order in the ",(0,n.jsx)(s.code,{children:"CREATE TABLE"})," statement. The order of ",(0,n.jsx)(s.code,{children:"DUPLICATE/UNIQUE/AGGREGATE KEY"})," needs to be consistent with the ",(0,n.jsx)(s.code,{children:"CREATE TABLE"})," statement. Take table ",(0,n.jsx)(s.code,{children:"site_access_duplicate"})," as an example, the following table building statement will throw an error."]}),"\n"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-SQL",children:"-- Wrong table building statement\nCREATE TABLE site_access_duplicate\n(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT DEFAULT '0'\n)\nDUPLICATE KEY(city_code, site_id)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n \n-- Correct table building statement\nCREATE TABLE site_access_duplicate\n(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT DEFAULT '0'\n)\nDUPLICATE KEY(site_id, city_code)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n"})}),"\n",(0,n.jsx)(s.p,{children:":-: Figure 5.2: DUPLICATE KEY columns are not in the same sorting order as in CREATE TABLE"}),"\n",(0,n.jsx)(s.p,{children:"Let's look at what you can achieve by using sort keys in a query. Under different situations, the sort keys in Figure 1 can affect your query performance in different ways:"}),"\n",(0,n.jsxs)(s.p,{children:["1.If the query contains both",(0,n.jsx)(s.code,{children:"site_id"})," and ",(0,n.jsx)(s.code,{children:"city_code"})," in its",(0,n.jsx)(s.code,{children:"where"})," clause, the data rows scanned will be significantly reduced. For example:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-SQL",children:"select sum(pv) from site_access_duplicate where site_id = 123 and city_code = 2;\n"})}),"\n",(0,n.jsxs)(s.p,{children:["2.If the query contains only the ",(0,n.jsx)(s.code,{children:"site_id"})," in its ",(0,n.jsx)(s.code,{children:"where"})," clause, it can also locate the matching data rows efficiently. For example:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-SQL",children:"select sum(pv) from site_access_duplicate where site_id = 123;\n"})}),"\n",(0,n.jsxs)(s.p,{children:["3.If the query contains only the ",(0,n.jsx)(s.code,{children:"city_code"})," in its ",(0,n.jsx)(s.code,{children:"where"})," clause, all the data rows need to be scanned, and the performance will deteriorate. For example:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-SQL",children:"select sum(pv) from site_access_duplicate where city_code = 2;\n"})}),"\n",(0,n.jsxs)(s.p,{children:["In the first case, a binary search will be performed to find the specified range. If the table contains a great number of rows, doing a binary search directly on ",(0,n.jsx)(s.code,{children:"site_id"})," and ",(0,n.jsx)(s.code,{children:"city_code"})," needs to load both columns into the memory. This will consume a lot of memory space. As an optimization, StarRocks introduces sparse ",(0,n.jsx)(s.strong,{children:"shortkey indices"})," based on sort keys. The size of the sort index will be 1024 times smaller than the original size of data, so it will be fully cached in the memory, which effectively speeds up the query during the actual lookups. When there is a large number of sort key columns, it will still consume too muchmemory. To avoid it, we have the following restrictions on the shortkey indices:"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"A shortkey column can only be the prefix of s sort key;"}),"\n",(0,n.jsx)(s.li,{children:"There can only be at most 3 shortkey columns;"}),"\n",(0,n.jsx)(s.li,{children:"A short key column cannot exceed 36 bytes;"}),"\n",(0,n.jsx)(s.li,{children:"The short key columns cannot be columns of type FLOAT/DOUBLE;"}),"\n",(0,n.jsx)(s.li,{children:"There can be at most one VARCHAR columns, and it can only appear at the end;"}),"\n",(0,n.jsx)(s.li,{children:"The length of shortkey can exceed 36 bytes when the last column of shortkey index is of CHAR or VARCHAR type;"}),"\n",(0,n.jsxs)(s.li,{children:["The above restrictions don\u2019t apply when user specifies ",(0,n.jsx)(s.code,{children:'PROPERTIES {short_key = "integer"}'})," in the table building statement."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"how-to-choose-the-sort-key",children:"How to choose the sort key"}),"\n",(0,n.jsxs)(s.p,{children:["It is very important to choose the right sort key to accelerate queries. For example, if the user only selects ",(0,n.jsx)(s.code,{children:"city_code"})," as the query condition when querying the table ",(0,n.jsx)(s.code,{children:"site_access_duplicate"}),", it results in bad query performance. You should make the columns that are frequently used as query conditions as sort keys."]}),"\n",(0,n.jsxs)(s.p,{children:["When there are multiple sort key columns, the order of the sort key columns also matters. The columns with high value distribution and are frequently used in queries should be placed at the front. In the table ",(0,n.jsx)(s.code,{children:"site_access_duplicate"}),", ",(0,n.jsx)(s.code,{children:"city_code"})," only allows a fixed set of values (the number of cities is fixed), while the number of possible values of ",(0,n.jsx)(s.code,{children:"site_id"})," is much larger than ",(0,n.jsx)(s.code,{children:"city_code"})," and keeps growing. So, the value distribution of ",(0,n.jsx)(s.code,{children:"site_id"})," is much higher than ",(0,n.jsx)(s.code,{children:"city_code"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["Still use the table ",(0,n.jsx)(s.code,{children:"site_access_duplicate"})," as an example:"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["If a user frequently use both ",(0,n.jsx)(s.code,{children:"site_id"})," and ",(0,n.jsx)(s.code,{children:"city_code"})," in queries, having ",(0,n.jsx)(s.code,{children:"site_id"})," as the first sort key column is more efficient."]}),"\n",(0,n.jsxs)(s.li,{children:["If a user queries by ",(0,n.jsx)(s.code,{children:"city_code"})," more frequently than usingthe combination of ",(0,n.jsx)(s.code,{children:"site_id"})," and ",(0,n.jsx)(s.code,{children:"city_code"}),", then having ",(0,n.jsx)(s.code,{children:"city_code"})," as the first sort key column is more appropriate."]}),"\n",(0,n.jsxs)(s.li,{children:["If querying by ",(0,n.jsx)(s.code,{children:"city_code"})," and by ",(0,n.jsx)(s.code,{children:"city_code"}),"+",(0,n.jsx)(s.code,{children:"site_id"})," are both frequent use cases, querying by ",(0,n.jsx)(s.code,{children:"city_code"})," alone may trigger a full scan of all the row and result in deteriorated performance. In this case, it would be more efficient to create a RollUp table with ",(0,n.jsx)(s.code,{children:"city_code"})," as the first column. The RollUp table will then build another Sort Index for ",(0,n.jsx)(s.code,{children:"city_code"})," to speed up the query.`"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"notes",children:"Notes"}),"\n",(0,n.jsx)(s.p,{children:"Since the shortkey index has a fixed size in StarRocks (36 bytes), memory bloating won\u2019t be an issue. However, you should keep the following 4 rules in mind."}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"The sort key columns must start from the first table column and have to be consecutive."}),"\n",(0,n.jsx)(s.li,{children:"The order of the sort keys is determined by the order of the columns defined in the create table statement."}),"\n",(0,n.jsx)(s.li,{children:"Do not use too many sort key columns. If a large number of columns are selected as sort keys, the sorting overhead will result in an increased of data import overhead."}),"\n",(0,n.jsx)(s.li,{children:"Oftentimes the first few sort key columns can already locate the range of the rows. Adding more sort key columns will not improve the query performance."}),"\n"]})]})}const h=function(e={}){const{wrapper:s}=Object.assign({},(0,i.ah)(),e.components);return s?(0,n.jsx)(s,Object.assign({},e,{children:(0,n.jsx)(a,e)})):a(e)}},11151:(e,s,t)=>{t.d(s,{Zo:()=>r,ah:()=>o});var n=t(67294);const i=n.createContext({});function o(e){const s=n.useContext(i);return n.useMemo((()=>"function"==typeof e?e(s):{...s,...e}),[s,e])}const c={};function r({components:e,children:s,disableParentContext:t}){let r;return r=t?"function"==typeof e?e({}):e||c:o(e),n.createElement(i.Provider,{value:r},s)}}}]);