"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[24606],{36232:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>t,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>c});var i=l(85893),s=l(11151);const a={displayed_sidebar:"English"},r="ALTER TABLE",d={id:"sql-reference/sql-statements/data-definition/ALTER_TABLE",title:"ALTER TABLE",description:"description",source:"@site/versioned_docs/version-2.1/sql-reference/sql-statements/data-definition/ALTER_TABLE.md",sourceDirName:"sql-reference/sql-statements/data-definition",slug:"/sql-reference/sql-statements/data-definition/ALTER_TABLE",permalink:"/docs/2.1/sql-reference/sql-statements/data-definition/ALTER_TABLE",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/sql-reference/sql-statements/data-definition/ALTER_TABLE.md",tags:[],version:"2.1",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"ALTER DATABASE",permalink:"/docs/2.1/sql-reference/sql-statements/data-definition/ALTER_DATABASE"},next:{title:"ALTER VIEW",permalink:"/docs/2.1/sql-reference/sql-statements/data-definition/ALTER_VIEW"}},t={},c=[{value:"description",id:"description",level:2},{value:"example",id:"example",level:2},{value:"keyword",id:"keyword",level:2}];function o(e){const n=Object.assign({h1:"h1",h2:"h2",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",ul:"ul"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"alter-table",children:"ALTER TABLE"}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"description"}),"\n",(0,i.jsx)(n.p,{children:"This statement is used to modify an existing table. If no rollup index is specified, the default operation is base index."}),"\n",(0,i.jsx)(n.p,{children:"The statement is divided into three types of operations: schema change, rollup, partition, which cannot appear in an ALTER TABLE statement at the same time. Schema change and rollup are asynchronous operations and are returned if the task is submitted successfully. User can then use the SHOW ALTER command to check the progress."}),"\n",(0,i.jsx)(n.p,{children:"Partition is a synchronous operation, and a command return indicates that execution is finished."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"ALTER TABLE [database.]table\nalter_clause1[, alter_clause2, ...];\n"})}),"\n",(0,i.jsx)(n.p,{children:"alter_clause is divided into partition, rollup, schema change, rename, index and swap."}),"\n",(0,i.jsx)(n.p,{children:"Partition supports the following several modifications:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add partitions"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'ADD PARTITION [IF NOT EXISTS] partition_name\npartition_desc ["key"="value"]\n[DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num]]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Partition_desc supports the following two expressions:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'VALUES LESS THAN [MAXVALUE|("value1", ...)]'}),"\n",(0,i.jsx)(n.li,{children:'VALUES [("value1", ...), ("value1", ...))'}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"partition is the left-closed-right-open interval. If the user only specifies the right boundary, the system will automatically determine the left boundary."}),"\n",(0,i.jsx)(n.li,{children:"If the bucket mode is not specified, the bucket method used by the built-in table is automatically used."}),"\n",(0,i.jsx)(n.li,{children:"If the bucket mode is specified, only the bucket number can be modified, and the bucket mode or bucket column cannot be modified."}),"\n",(0,i.jsx)(n.li,{children:'User can set some properties of the partition in ["key"="value"] (see CREATE TABLE for details).'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop partitions"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"DROP PARTITION [IF EXISTS | FORCE] partition_name\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Keep at least one partition for partitioned tables."}),"\n",(0,i.jsx)(n.li,{children:"After executing DROP PARTITION for a while, the dropped partition can be recovered by the RECOVER statement. See the RECOVER statement for details."}),"\n",(0,i.jsx)(n.li,{children:"If DROP PARTITION FORCE is executed, the partition will be deleted directly and cannot be recovered without checking whether there are any unfinished activities on the partition. Thus, generally this operation is not recommended."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify partition properties"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'MODIFY PARTITION p1|(p1[, p2, ...]) SET ("key" = "value", ...)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The following properties of the partition can currently be modified."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"storage_medium"}),"\n",(0,i.jsx)(n.li,{children:"storage_cooldown_time"}),"\n",(0,i.jsx)(n.li,{children:"replication_num"}),"\n",(0,i.jsx)(n.li,{children:"in_memory"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For single-partition tables, partition_name is the same as the table name."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Rollup supports the following creation modes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create a rollup index"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'ADD ROLLUP rollup_name (column_name1, column_name2, ...)\n[FROM from_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.p,{children:"properties: Support setting timeout time and the default timeout time is one day."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"ADD ROLLUP r1(col1,col2) from r0\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Creating rollup index in batches"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'ADD ROLLUP [rollup_name (column_name1, column_name2, ...)\n[FROM from_index_name]\n[PROPERTIES ("key"="value", ...)],...]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:"ADD ROLLUP r1(col1,col2) from r0, r2(col3,col4) from r0\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If from_index_name is not specified, then create from base index by default."}),"\n",(0,i.jsx)(n.li,{children:"The columns in the rollup table must be existing columns in from_index."}),"\n",(0,i.jsx)(n.li,{children:"In properties, user can specify the storage format. See CREATE TABLE for details."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop the rollup index."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-SQL",children:'DROP ROLLUP rollup_name [PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.p,{children:"DROP ROLLUP r1"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Batch dropping rollup index"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'DROP ROLLUP [rollup_name [PROPERTIES ("key"="value", ...)],...]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Example: DROP ROLLUP r1,r2\n2.2 Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"You cannot drop the base index."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"schema change supports the following modifications:"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add a column to the specified location of the specified index"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ADD COLUMN column_name column_type [KEY | agg_type] [DEFAULT "default_value"]\n[AFTER column_name|FIRST]\n[TO rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plain",metastring:"text",children:"1. If you add a value column to aggregation model, you need to specify agg_type.\n2. If you add a key column to non-aggregation models (such as DUPLICATE KEY) , you need to specify the KEY keyword.\n3. You cannot add a column that already exists in the base index to the rollup index.\n (You can recreate a rollup index if needed)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add multiple columns to the specified index."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ADD COLUMN (column_name1 column_type [KEY | agg_type] DEFAULT "default_value", ...)\n[TO rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If you add value columnin aggregation models, you need to specify agg_type."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If you add a key column in non-aggregation models, you need to specify the KEY keyword."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"You cannot add a column that already exists in the base index to the rollup index."}),"\n",(0,i.jsx)(n.p,{children:"(You can recreate a rollup index if needed)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop a column from the specified index."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"DROP COLUMN column_name\n[FROM rollup_index_name]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"You cannot drop partition column."}),"\n",(0,i.jsx)(n.li,{children:"If the column is dropped from the base index, it will also be dropped if it is included in the rollup index."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify the column type and column position of the specified index."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'MODIFY COLUMN column_name column_type [KEY | agg_type] [NULL | NOT NULL] [DEFAULT "default_value"]\n[AFTER column_name|FIRST]\n[FROM rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If you modify the value column in aggregation models, you need to specify agg_type."}),"\n",(0,i.jsx)(n.li,{children:"If you modify the key column in non-aggregation models, you need to specify the KEY keyword."}),"\n",(0,i.jsx)(n.li,{children:"Only the type of column can be modified. The other properties of the column remain as they are currently. (i.e. other properties need to be explicitly written in the statement according to the original property, see example 8)."}),"\n",(0,i.jsx)(n.li,{children:"The partition column cannot be modified."}),"\n",(0,i.jsxs)(n.li,{children:["The following types of conversions are currently supported (accuracy loss is guaranteed by the user).\nConvert TINYINT/SMALLINT/INT/BIGINT to TINYINT/SMALLINT/INT/BIGINT/DOUBLE.\nConvert TINTINT/SMALLINT/INT/BIGINT/LARGEINT/FLOAT/DOUBLE/DECIMAL to VARCHAR.\nVARCHAR supports modification of maximum length.\nConvert VARCHAR to TINTINT/SMALLINT/INT/BIGINT/LARGEINT/FLOAT/DOUBLE.\nConvert VARCHAR to DATE (currently support six formats: ",(0,i.jsx)(n.code,{children:"%Y-%m-%d"}),", ",(0,i.jsx)(n.code,{children:"%y-%m-%d"}),", ",(0,i.jsx)(n.code,{children:"%Y%m%d"}),", ",(0,i.jsx)(n.code,{children:"%y%m%d"}),", ",(0,i.jsx)(n.code,{children:"%Y/%m/%d"}),", ",(0,i.jsx)(n.code,{children:"%y/%m/%d"}),")\nConvert DATETIME to DATE(only year-month-day information is retained, i.e.  ",(0,i.jsx)(n.code,{children:"2019-12-09 21:47:05"})," ",(0,i.jsx)(n.code,{children:"<--\x3e"})," ",(0,i.jsx)(n.code,{children:"2019-12-09"}),")\nConvert DATE to DATETIME (set hour, minute, second to zero, For example: ",(0,i.jsx)(n.code,{children:"2019-12-09"})," ",(0,i.jsx)(n.code,{children:"<--\x3e"})," ",(0,i.jsx)(n.code,{children:"2019-12-09 00:00:00"}),")\nConvert FLOAT to DOUBLE\nConvert INT to DATE (If the INT data fails to convert, the original data remains the same)"]}),"\n",(0,i.jsx)(n.li,{children:"Does not support conversion from NULL to NOT NULL."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Reorder the columns of the specified index."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ORDER BY (column_name1, column_name2, ...)\n[FROM rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"All columns in the index must be written."}),"\n",(0,i.jsx)(n.li,{children:"The value column is listed after the key column."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify the properties of table. It urrently supports modifying the bloom filter column, the colocate_with property and the dynamic_partition property, the replication_num property and default.replication_num property."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'PROPERTIES ("key"="value")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note:\nYou can also modify the properties by merging into the above schema change operation. See the example below:"}),"\n",(0,i.jsx)(n.p,{children:"rename supports modification of the following names:"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"example"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify the table name"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"RENAME new_table_name;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify the rollup index name"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"RENAME ROLLUP old_rollup_name new_rollup_name;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify the partition name"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"RENAME PARTITION old_partition_name new_partition_name;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"bitmap index supports the following modifications:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create a bitmap index"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ADD INDEX index_name (column [, ...],) [USING BITMAP] [COMMENT 'balabala'];\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plain",metastring:"text",children:"1. Bitmap index is only supported for the current version.\n2. A BITMAP index is created only in a single column.\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop index"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"DROP INDEX index_name\uff1b\n"})}),"\n",(0,i.jsx)(n.p,{children:"swap supports the atomic exchange of two tables."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Atomic exchange of two tables."}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SWAP WITH table_name\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[table]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the default number of replications of the table, which is used as the default number of the replications."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nSET ("default.replication_num" = "2");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the actual number of replications of  a single-partition table (single-partition table only)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nSET ("replication_num" = "3");\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[partition]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add partition. Existing partition [MIN, 2013-01-01), add partition [2013-01-01, 2014-01-01), and use default bucket mode."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD PARTITION p1 VALUES LESS THAN ("2014-01-01");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add partition and use the new number of buckets."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD PARTITION p1 VALUES LESS THAN ("2015-01-01")\nDISTRIBUTED BY HASH(k1) BUCKETS 20;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add partition and use the new number of replications."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD PARTITION p1 VALUES LESS THAN ("2015-01-01")\n("replication_num"="1");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the number of partition replications."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nMODIFY PARTITION p1 SET("replication_num"="1");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Batch altering the specified partitions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nMODIFY PARTITION (p1, p2, p4) SET("in_memory"="true");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Batch altering all partitions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nMODIFY PARTITION (*) SET("storage_medium"="HDD");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop partition."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nDROP PARTITION p1;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add a partition that specifies upper and lower bounds."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD PARTITION p1 VALUES [("2014-01-01"), ("2014-02-01"));\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[rollup]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create index: example_rollup_index, based on base index(k1,k2,k3,v1,v2). Column-based storage."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD ROLLUP example_rollup_index(k1, k3, v1, v2)\nPROPERTIES("storage_type"="column");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create index: example_rollup_index2, based on example_rollup_index(k1,k3,v1,v2)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nADD ROLLUP example_rollup_index2 (k1, v1)\nFROM example_rollup_index;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create index: example_rollup_index3, based on base index (k1, k2, k3, v1), and custom rollup timeout time is one hour."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD ROLLUP example_rollup_index(k1, k3, v1)\nPROPERTIES("storage_type"="column", "timeout" = "3600");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop index: example_rollup_index2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nDROP ROLLUP example_rollup_index2;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[SchemaChange]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add a key column new_col (non-aggregation model) to the col1 of example_rollup_index."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN new_col INT KEY DEFAULT "0" AFTER col1\nTO example_rollup_index;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add a value column new_col (non-aggregation model) to the col1 of example_rollup_index."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN new_col INT DEFAULT "0" AFTER col1\nTO example_rollup_index;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add a key column new_col (aggregation model) to col1 of example_rollup_index."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN new_col INT DEFAULT "0" AFTER col1\nTO example_rollup_index;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add a value column new_col SUM (aggregation model) to the col1 of example_rollup_index."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN new_col INT SUM DEFAULT "0" AFTER col1\nTO example_rollup_index;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add multiple columns to the example_rollup_index (aggregation model)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN (col1 INT DEFAULT "1", col2 FLOAT SUM DEFAULT "2.3")\nTO example_rollup_index;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop a column from example_rollup_index."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nDROP COLUMN col2\nFROM example_rollup_index;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Modify col1 column type of the base index to BIGINT and put it after col2 column."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nMODIFY COLUMN col1 BIGINT DEFAULT "1" AFTER col2;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'Modify the maximum length of the val1 column of the base index. The original val1 is (val1 VARCHAR(32) REPLACE DEFAULT "abc").'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nMODIFY COLUMN val1 VARCHAR(64) REPLACE DEFAULT "abc";\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Reorder the columns in example_rollup_index (set the original column order: k1, k2, k3, v1, v2)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nORDER BY (k3,k1,k2,v2,v1)\nFROM example_rollup_index;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Perform both operations simultaneously."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN v2 INT MAX DEFAULT "0" AFTER k2 TO example_rollup_index,\nORDER BY (k3,k1,k2,v2,v1) FROM example_rollup_index;\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the bloom filter column of the table."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table SET ("bloom_filter_columns"="k1,k2,k3");\n'})}),"\n",(0,i.jsx)(n.p,{children:"It can also be merged into the above schema change operation (note that the syntax of multiple clauses is slightly different)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nDROP COLUMN col2\nPROPERTIES ("bloom_filter_columns"="k1,k2,k3");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the Colocate property of the table."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table set ("colocate_with" = "t1");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the bucketing mode of the table from Random Distribution to Hash Distribution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table set ("distribution_type" = "hash");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the dynamic partition properties of the table (support adding dynamic partition properties to tables)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table set ("dynamic_partition.enable" = "false");\n'})}),"\n",(0,i.jsx)(n.p,{children:"If you need to add dynamic partition attributes to a table without dynamic partition properties, you need to specify all dynamic partition properties."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table set ("dynamic_partition.enable" = "true", "dynamic_partition.time_unit" = "DAY", "dynamic_partition.end" = "3", "dynamic_partition.prefix" = "p", "dynamic_partition.buckets" = "32");\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Alter the in_memory property of the table."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table set ("in_memory" = "true");\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[rename]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Rename table1 to table2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE table1 RENAME table2;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Rename rollup index rollup1 of example_table to rollup2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_table RENAME ROLLUP rollup1 rollup2;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Rename partition p1 of example_table to p2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_table RENAME PARTITION p1 p2;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[index]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create bitmap index for column siteid on table1."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE table1 ADD INDEX index_name (siteid) [USING BITMAP] COMMENT 'balabala';\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Drop bitmap index of siteid column on table1."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE table1 DROP INDEX index_name;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"[swap]"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Atomic swap between table1 and table2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE table1 SWAP WITH table2\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"keyword",children:"keyword"}),"\n",(0,i.jsx)(n.p,{children:"ALTER,TABLE,ROLLUP,COLUMN,PARTITION,RENAME,SWAP"})]})}const p=function(e={}){const{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(o,e)})):o(e)}},11151:(e,n,l)=>{l.d(n,{Zo:()=>d,ah:()=>a});var i=l(67294);const s=i.createContext({});function a(e){const n=i.useContext(s);return i.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const r={};function d({components:e,children:n,disableParentContext:l}){let d;return d=l?"function"==typeof e?e({}):e||r:a(e),i.createElement(s.Provider,{value:d},n)}}}]);