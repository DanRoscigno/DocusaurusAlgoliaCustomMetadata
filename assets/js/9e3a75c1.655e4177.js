"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[29694],{71862:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(85893),r=n(11151);const i={displayed_sidebar:"English"},a="Backup and Recovery",o={id:"administration/Backup_and_restore",title:"Backup and Recovery",description:"StarRocks supports backing up the current data as a file to a remote storage system via the broker (the broker is an optional process in the StarRocks cluster, mainly used to support StarRocks to read and write files and directories on the remote storage, please refer to the Broker Load documentation. The backup data can be restored from the remote storage system to any StarRocks cluster with the restore command. This feature supports periodic snapshot backup of data. It also allows migrating data between clusters.",source:"@site/versioned_docs/version-2.1/administration/Backup_and_restore.md",sourceDirName:"administration",slug:"/administration/Backup_and_restore",permalink:"/docs/2.1/administration/Backup_and_restore",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/administration/Backup_and_restore.md",tags:[],version:"2.1",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"Authentication methods",permalink:"/docs/2.1/administration/Authentication"},next:{title:"Blacklist Management",permalink:"/docs/2.1/administration/Blacklist"}},l={},c=[{value:"Principle Description",id:"principle-description",level:2},{value:"Backup",id:"backup",level:3},{value:"Restore",id:"restore",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Data Backup",id:"data-backup",level:3},{value:"Data Migration",id:"data-migration",level:3},{value:"Notes",id:"notes",level:2},{value:"Related Commands",id:"related-commands",level:2}];function h(e){const t=Object.assign({h1:"h1",p:"p",a:"a",code:"code",h2:"h2",h3:"h3",ol:"ol",li:"li",ul:"ul"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"backup-and-recovery",children:"Backup and Recovery"}),"\n",(0,s.jsxs)(t.p,{children:["StarRocks supports backing up the current data as a file to a remote storage system via the broker (the broker is an optional process in the StarRocks cluster, mainly used to support StarRocks to read and write files and directories on the remote storage, please refer to the ",(0,s.jsx)(t.a,{href:"/docs/2.1/loading/BrokerLoad",children:"Broker Load documentation"}),". The backup data can be restored from the remote storage system to any StarRocks cluster with the restore command. This feature supports periodic snapshot backup of data. It also allows migrating data between clusters."]}),"\n",(0,s.jsxs)(t.p,{children:["To use this feature, you need to deploy a broker that corresponds to the remote storage system, such as HDFS. You can check the broker information by ",(0,s.jsx)(t.code,{children:"SHOW BROKER;"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"principle-description",children:"Principle Description"}),"\n",(0,s.jsx)(t.h3,{id:"backup",children:"Backup"}),"\n",(0,s.jsx)(t.p,{children:"Backup is to upload data from a specified table or partition to a remote repository in the form of a file stored by StarRocks. When a user submits a Backup request, the system executes the following operations internally:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Snapshot and Snapshot Upload","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"First, it takes a snapshot of the data in the specified table or partition . The backup is performed on the snapshot. After the snapshot, any operation made to the table no longer affects the backup result. The snapshot quickly produces a hard link to the current data file. Once the snapshot is complete, the snapshot files are uploaded one by one. Snapshot upload is done concurrently by each Backend."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Metadata Preparation and Upload","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"After the snapshot upload is completed, Frontend will write the corresponding metadata to a local file, and then upload this file to the remote repository through the broker."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"restore",children:"Restore"}),"\n",(0,s.jsx)(t.p,{children:"The restore operation requires specifying a backup that already exists in the remote repository and will restore the contents of this backup to the local cluster. When the user submits a Restore request, the system executes the following operations internally."}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Create the corresponding metadata locally"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"This step first creates a structure such as a table partition in the local cluster that corresponds to the restore request. Once created, the table will be visible, but not accessible."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"local snapshot"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"This step takes a snapshot of the table created in the previous step. The snapshot will be empty because the newly created table has no data. The purpose of this step is to generate the corresponding snapshot directory on Backend, which can be used to receive the snapshot files downloaded from the remote repository later."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"download the snapshot"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The snapshot file from the remote repository is downloaded to the corresponding snapshot directory generated in the previous step. This step is done concurrently by each Backend."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"ready to use"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"After the snapshots are downloaded, the individual snapshots are mapped to the current local table metadata. These snapshots are then reloaded to be ready to use and complete the final recovery operation."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Overall Process"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["First create a cloud repository for both old and new clusters with the same ",(0,s.jsx)(t.code,{children:"REPOSITORY"})," name. The BROKER Name can be checked in the cluster. Second, in the old cluster, prepare the tables that need to be migrated and backed up. Third, back up those tables to the cloud repository, and then Restore from the cloud repository to the new cluster."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"The tables to be backed up and restored do not need to be created in advance in the new cluster, because they will be created automatically when the Restore operation is performed."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(t.h3,{id:"data-backup",children:"Data Backup"}),"\n",(0,s.jsx)(t.p,{children:"Currently StarRocks supports full backups at the partition level. If you need to perform regular backups, plan the partitioning and bucketing wisely when creating tables. Later you can perform data backups regularly for each partition."}),"\n",(0,s.jsx)(t.h3,{id:"data-migration",children:"Data Migration"}),"\n",(0,s.jsx)(t.p,{children:"To complete data migration, users can back up data to a remote repository and then restore data from the repository to another cluster. Because data backup is done in the form of snapshots, any data that is imported after the snapshot phase will not be backed up. Therefore, any data imported to the original cluster during the grace period needs to be imported again to the new cluster. It is recommended to perform parallel import to both clusters after the migration is completed. Complete data verification and then migrate the business to the new cluster."}),"\n",(0,s.jsx)(t.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"B Only ADMIN users can perform backup and recovery operations."}),"\n",(0,s.jsx)(t.li,{children:"Only one active backup or recovery job can run in a Database."}),"\n",(0,s.jsx)(t.li,{children:"Both backup and recovery can be performed at the partition level. For large volume data, it is recommended to perform the operations separately by partition to reduce retries after failures."}),"\n",(0,s.jsxs)(t.li,{children:["Backup and recovery operations are performed on the actual data files. When a table has too many tablets or minor versions, it takes a long time to back up or restore even if the total data volume is small. Users can estimate the job execution time by viewing the number of tablets and the number of file versions in each partition with ",(0,s.jsx)(t.code,{children:"SHOW PARTITIONS FROM table_name;"})," and ",(0,s.jsx)(t.code,{children:"SHOW TABLET FROM table_name;"})," respectively. The number of files has a great impact on the job execution time, so it is recommended to plan the partitioning and bucketing wisely."]}),"\n",(0,s.jsxs)(t.li,{children:["When checking the job status with ",(0,s.jsx)(t.code,{children:"SHOW BACKUP"})," or ",(0,s.jsx)(t.code,{children:"SHOW RESTORE"}),", you may see an error message in the TaskErrMsg column. However, as long as the State column is not ",(0,s.jsx)(t.code,{children:"CANCELLED"}),", the job is still running. Some tasks may be retried successfully. Some Task errors may cause the job to fail directly."]}),"\n",(0,s.jsxs)(t.li,{children:["If the recovery job is an overwrite operation, i.e., it specifies to restore data to an existing table or partition, then the data overwritten on the current cluster may not be restored from the ",(0,s.jsx)(t.code,{children:"COMMIT"})," phase. If the recovery job fails or is canceled at this point, it is possible that the previous data is corrupted and inaccessible. In this case, you can only recover the data by performing the recovery operation again and waiting for the job to complete. Therefore, try not to use overwrite to recover data unless it is confirmed that the current data is no longer in use. The overwrite operation checks whether the metadata of the snapshot is the same as the existing table or partition. If different, the recovery operation cannot be executed."]}),"\n",(0,s.jsx)(t.li,{children:"The snapshot data currently cannot be deleted directly by StarRocks.Users can manually delete the snapshot paths backed up in the remote storage system."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"related-commands",children:"Related Commands"}),"\n",(0,s.jsx)(t.p,{children:"The following commands are related to the backup and recovery operations."}),"\n",(0,s.jsx)(t.p,{children:"CREATE REPOSITORY"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Create a remote repository path for backup or recovery. This command requires access to the remote storage system via Broker. Different Brokers need different parameters, see [Broker documentation](. /loading/BrokerLoad.md). The backup and recovery clusters need to create the same repository, including the repository path and repository name, which allows the  recovery cluster to read the backup snapshot of the backup cluster."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"BACKUP"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Perform a backup operation."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"SHOW BACKUP"}),"\n",(0,s.jsx)(t.p,{children:"View the execution status of the last backup job, including:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"JobId: The id of this backup job."}),"\n",(0,s.jsx)(t.li,{children:"SnapshotName: The user-specified name (Label) of this backup job."}),"\n",(0,s.jsx)(t.li,{children:"DbName: The Database for the backup job."}),"\n",(0,s.jsxs)(t.li,{children:["State: The current phase of the backup job.","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"PENDING: The initial state of the job."}),"\n",(0,s.jsx)(t.li,{children:"SNAPSHOTING: The snapshot operation is in progress."}),"\n",(0,s.jsx)(t.li,{children:"UPLOAD_SNAPSHOT: The snapshot is ready to be uploaded."}),"\n",(0,s.jsx)(t.li,{children:"UPLOADING: The snapshot is being uploaded."}),"\n",(0,s.jsx)(t.li,{children:"SAVE_META: Metadata file is being generated locally."}),"\n",(0,s.jsx)(t.li,{children:"UPLOAD_INFO: Uploading metadata file and job information."}),"\n",(0,s.jsx)(t.li,{children:"FINISHED: Backup is complete."}),"\n",(0,s.jsx)(t.li,{children:"CANCELLED: Backup failed or was cancelled."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.li,{children:"BackupObjs: A list of the tables and partitions involved in this backup."}),"\n",(0,s.jsx)(t.li,{children:"CreateTime: The time when the job was created."}),"\n",(0,s.jsx)(t.li,{children:"SnapshotFinishedTime: The completion time of the snapshot."}),"\n",(0,s.jsx)(t.li,{children:"UploadFinishedTime: The time when the snapshot was uploaded successfully."}),"\n",(0,s.jsx)(t.li,{children:"FinishedTime: The completion time of this job."}),"\n",(0,s.jsx)(t.li,{children:"UnfinishedTasks: There will be multiple subtasks in progress, such as SNAPSHOTTING, UPLOADING, etc. Here are the task ids of the incomplete subtasks."}),"\n",(0,s.jsx)(t.li,{children:"TaskErrMsg: If there is a subtask execution error, the error message will be displayed here."}),"\n",(0,s.jsx)(t.li,{children:"Status: The status that may occur when the job is running."}),"\n",(0,s.jsx)(t.li,{children:'Timeout: The timeout of the job, in "seconds".'}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"SHOW SNAPSHOT"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"View the backups that already exist in the remote repository."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Snapshot: The name (Label) of this backup specified at backup time."}),"\n",(0,s.jsx)(t.li,{children:"Timestamp: The timestamp of the backup."}),"\n",(0,s.jsx)(t.li,{children:"Status: Whether the backup is normal or not."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["If you specify the ",(0,s.jsx)(t.code,{children:"where"})," clause after ",(0,s.jsx)(t.code,{children:"SHOW SNAPSHOT"}),", you will see more detailed backup information."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Database: The corresponding Database."}),"\n",(0,s.jsx)(t.li,{children:"Details:  A holistic view of the backup data directory."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"RESTORE"}),"\n",(0,s.jsx)(t.p,{children:"Perform a restore operation."}),"\n",(0,s.jsx)(t.p,{children:"SHOW RESTORE"}),"\n",(0,s.jsx)(t.p,{children:"View the execution of the most recent recovery job, including:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"JobId: The id of this recovery job."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Label: The name (Label) of the backup in the repository."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Timestamp: The timestamp of the backup in the repository."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"DbName: The Database corresponding to the recovery job."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"State: The current phase of the recovery job."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"PENDING: The initial state of the job."}),"\n",(0,s.jsx)(t.li,{children:"SNAPSHOTTING: Snapshot is being performed."}),"\n",(0,s.jsx)(t.li,{children:"DOWNLOAD: Snapshot downloading task is being sent."}),"\n",(0,s.jsx)(t.li,{children:"DOWNLOADING: Snapshot is being downloaded."}),"\n",(0,s.jsx)(t.li,{children:"COMMIT: Preparing to validate a downloaded snapshot."}),"\n",(0,s.jsx)(t.li,{children:"COMMITTING: The downloaded snapshot is being validated."}),"\n",(0,s.jsx)(t.li,{children:"FINISHED: Recovery is complete."}),"\n",(0,s.jsx)(t.li,{children:"CANCELLED: Recovery failed or was canceled."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"AllowLoad: Whether import is allowed during recovery."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"ReplicationNum: The number of replications."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"RestoreObjs: A list of the tables and partitions involved in this recovery job."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"CreateTime: The time when the job was created."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"MetaPreparedTime: The time when the local metadata generation is completed."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"SnapshotFinishedTime: Completion time of Local snapshot."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"DownloadFinishedTime: Completion time of remote snapshot download."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"FinishedTime: Completion time of this job."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"UnfinishedTasks: There will be multiple subtasks in progress, such as S SNAPSHOTTING, DOWNLOADING, COMMITTING, etc. Here are the task ids of the incomplete subtasks."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"TaskErrMsg: If there is a subtask execution error, the error message will be displayed here."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Status: The status that may occur when the job is running."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Timeout: The timeout of the job, in seconds."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"CANCEL BACKUP"}),"\n",(0,s.jsx)(t.p,{children:"Cancel the running backup job."}),"\n",(0,s.jsx)(t.p,{children:"CANCEL RESTORE"}),"\n",(0,s.jsx)(t.p,{children:"Cancel the running recovery job."}),"\n",(0,s.jsx)(t.p,{children:"DROP REPOSITORY"}),"\n",(0,s.jsx)(t.p,{children:"Delete a remote repository that has been created. Deleting a repository only removes the mapping of that repository in StarRocks, not the actual repository data."})]})}const d=function(e={}){const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?(0,s.jsx)(t,Object.assign({},e,{children:(0,s.jsx)(h,e)})):h(e)}},11151:(e,t,n)=>{n.d(t,{Zo:()=>o,ah:()=>i});var s=n(67294);const r=s.createContext({});function i(e){const t=s.useContext(r);return s.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const a={};function o({components:e,children:t,disableParentContext:n}){let o;return o=n?"function"==typeof e?e({}):e||a:i(e),s.createElement(r.Provider,{value:o},t)}}}]);