"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[81756],{65939:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var i=n(85893),r=n(11151);const a={displayed_sidebar:"English"},d="Data Models",s={id:"table_design/Data_model",title:"Data Models",description:"According to the mapping relationship between ingested data and actual stored data, StarRocks provides corresponding data models for different types of tables. Here we reference the concept of primary key (in the relational model), and use the value of the key column as the sort key. Compared with the traditional primary key,StarRocks\u2019s sort key has these features:",source:"@site/versioned_docs/version-2.0/table_design/Data_model.md",sourceDirName:"table_design",slug:"/table_design/Data_model",permalink:"/docs/2.0/table_design/Data_model",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/table_design/Data_model.md",tags:[],version:"2.0",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"Data distribution",permalink:"/docs/2.0/table_design/Data_distribution"},next:{title:"Materialized View",permalink:"/docs/2.0/table_design/Materialized_view"}},l={},o=[{value:"Duplicate model",id:"duplicate-model",level:2},{value:"Scenarios for duplicate model",id:"scenarios-for-duplicate-model",level:3},{value:"Principle of duplicate model",id:"principle-of-duplicate-model",level:3},{value:"How to use duplicate model",id:"how-to-use-duplicate-model",level:3},{value:"Notes on duplicate model",id:"notes-on-duplicate-model",level:3},{value:"Aggregation model",id:"aggregation-model",level:2},{value:"Scenarios for aggregation model",id:"scenarios-for-aggregation-model",level:3},{value:"Principle of aggregation model",id:"principle-of-aggregation-model",level:3},{value:"How to use aggregation model",id:"how-to-use-aggregation-model",level:3},{value:"Notes on aggregation model",id:"notes-on-aggregation-model",level:3},{value:"Update model",id:"update-model",level:2},{value:"Scenarios for update model",id:"scenarios-for-update-model",level:3},{value:"Principle of update model",id:"principle-of-update-model",level:3},{value:"How to use update model",id:"how-to-use-update-model",level:3},{value:"Notes on update model",id:"notes-on-update-model",level:3}];function c(e){const t=Object.assign({h1:"h1",p:"p",ul:"ul",li:"li",code:"code",h2:"h2",h3:"h3",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"data-models",children:"Data Models"}),"\n",(0,i.jsx)(t.p,{children:"According to the mapping relationship between ingested data and actual stored data, StarRocks provides corresponding data models for different types of tables. Here we reference the concept of primary key (in the relational model), and use the value of the key column as the sort key. Compared with the traditional primary key,StarRocks\u2019s sort key has these features:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"All key columns are sort keys, so the sort key mentioned later is essentially a key column."}),"\n",(0,i.jsx)(t.li,{children:"Sort keys are repeatable and do not have to satisfy the uniqueness constraint."}),"\n",(0,i.jsx)(t.li,{children:"Each column of the table is stored by cluster in the order of the sorted keys."}),"\n",(0,i.jsx)(t.li,{children:"Sort keys use sparse indexes."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"There are three models that can be used to ingest multiple rows of data with duplicate primary keys and populate them to data tables:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Duplicate model: There are rows of data with duplicate primary keys in the table. The stored data and ingested data rows correspond to each other, so that users can recall all historical data."}),"\n",(0,i.jsx)(t.li,{children:"Aggregation model: There are no data rows with duplicate primary keys. In this case, those rows are merged into one row according to the aggregation function. Users can recall the aggregated results of all historical data, but not the data itself."}),"\n",(0,i.jsxs)(t.li,{children:["Update model: This is a special case of aggregation model. In this model, the primary key satisfies the uniqueness constraint, and the most recently ingested row replaces the other rows that have duplicate primary keys. This is equivalent to an aggregation model in which the aggregation function is ",(0,i.jsx)(t.code,{children:"REPLACE"}),", and the ",(0,i.jsx)(t.code,{children:"REPLACE"})," function returns the most recent data in the set."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Note:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"In the table build statement, the definition of the sort key must appear before the definition of the value column."}),"\n",(0,i.jsx)(t.li,{children:"The order of key columns appearing in the build statement determines the order of sort keys presented."}),"\n",(0,i.jsx)(t.li,{children:"The shortkey index contains several prefix columns of the sort key."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"duplicate-model",children:"Duplicate model"}),"\n",(0,i.jsx)(t.h3,{id:"scenarios-for-duplicate-model",children:"Scenarios for duplicate model"}),"\n",(0,i.jsx)(t.p,{children:"Duplicate model is the default model in StarRocks."}),"\n",(0,i.jsx)(t.p,{children:"The suitable scenarios have the following characteristics:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Need to retain the original data (e.g. logs, operational records, etc.) for analysis."}),"\n",(0,i.jsx)(t.li,{children:"Be able to query flexibly and not limited to pre-defined analytical methods, which are difficult to accomplish by traditional pre-aggregation methods."}),"\n",(0,i.jsx)(t.li,{children:"Infrequent data updates. The source of the imported data is usually log data or time-series data, which is mainly characterized by append write and the data itself will not change much after it is generated."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"principle-of-duplicate-model",children:"Principle of duplicate model"}),"\n",(0,i.jsx)(t.p,{children:"Users can specify the sort key of the table. If it\u2019s not explicitly specified, StarRocks will set default columns as the sort key. When the sort key is set as a filter, StarRocks can quickly filter the data and reduce query latency."}),"\n",(0,i.jsx)(t.p,{children:"Note: When importing two identical rows of data into a duplicate model table, StarRocks will consider them as two rows of data."}),"\n",(0,i.jsx)(t.h3,{id:"how-to-use-duplicate-model",children:"How to use duplicate model"}),"\n",(0,i.jsxs)(t.p,{children:["The table adopts the duplicate model by default. The sort key uses shortkey index to filter the data quickly. Users can consider setting the frequently used key column as sort key. For example, if you frequently view data for a certain type of event in a certain time range, you can set ",(0,i.jsx)(t.code,{children:"event time"})," and ",(0,i.jsx)(t.code,{children:"event type"})," as sort keys."]}),"\n",(0,i.jsx)(t.p,{children:"The following is an example of creating a data table using the duplicate model."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Where ",(0,i.jsx)(t.code,{children:"DUPLICATE KEY(event_time, event_type)"})," indicates that the duplicate model is used, and the sort key is defined before the definitions of other columns."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS detail (\n event_time DATETIME NOT NULL COMMENT "datetime of event",\n event_type INT NOT NULL COMMENT "type of event",\n user_id INT COMMENT "id of user"\n device_code INT COMMENT "device of",\n channel INT COMMENT ""\n)\nDUPLICATE KEY(event_time, event_type)\nDISTRIBUTED BY HASH(user_id) BUCKETS 8\n'})}),"\n",(0,i.jsx)(t.h3,{id:"notes-on-duplicate-model",children:"Notes on duplicate model"}),"\n",(0,i.jsx)(t.p,{children:"Make full use of the sort key by defining the frequently used columns up front to improve query speed. In the duplicate model, you can specify some of the key columns as sort keys, whereas in the aggregation model and update model, the sort keys can only be all key columns."}),"\n",(0,i.jsx)(t.h2,{id:"aggregation-model",children:"Aggregation model"}),"\n",(0,i.jsx)(t.h3,{id:"scenarios-for-aggregation-model",children:"Scenarios for aggregation model"}),"\n",(0,i.jsx)(t.p,{children:"Data statistics and aggregation are common concepts of data analysis. For example:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Website or APP owners monitor data on total visits and visit duration"}),"\n",(0,i.jsx)(t.li,{children:"Advertising vendors gather data onad clicks, total number of displays, and consumption statistics for advertisers;"}),"\n",(0,i.jsx)(t.li,{children:"Marketing people analyze data on annual transactions and top products of each demographic category for a specific quarter or month."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The suitable scenarios for  using aggregation model have the following characteristics:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Queries need to be aggregated through ",(0,i.jsx)(t.code,{children:"sum"}),", ",(0,i.jsx)(t.code,{children:"count"}),", and/or ",(0,i.jsx)(t.code,{children:"max"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"No need to recall the original data."}),"\n",(0,i.jsx)(t.li,{children:"Historical data will not be updated frequently;new data will be appended."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"principle-of-aggregation-model",children:"Principle of aggregation model"}),"\n",(0,i.jsx)(t.p,{children:"StarRocks aggregates value columns by corresponding key columns, which reduces the amount of data for processing and increases query efficiency."}),"\n",(0,i.jsx)(t.p,{children:"Take the following raw data as an example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{align:"center",children:"Date"}),(0,i.jsx)(t.th,{align:"center",children:"Country"}),(0,i.jsx)(t.th,{align:"center",children:"PV"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2020.05.01"}),(0,i.jsx)(t.td,{align:"center",children:"CHN"}),(0,i.jsx)(t.td,{align:"center",children:"1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2020.05.01"}),(0,i.jsx)(t.td,{align:"center",children:"CHN"}),(0,i.jsx)(t.td,{align:"center",children:"2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2020.05.01"}),(0,i.jsx)(t.td,{align:"center",children:"USA"}),(0,i.jsx)(t.td,{align:"center",children:"3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2020.05.01"}),(0,i.jsx)(t.td,{align:"center",children:"USA"}),(0,i.jsx)(t.td,{align:"center",children:"4"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"In the StarRocks aggregation model, the four rows of data are converted to two rows, which reduces the amount of data processed during the subsequent query."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{align:"center",children:"Date"}),(0,i.jsx)(t.th,{align:"center",children:"Country"}),(0,i.jsx)(t.th,{align:"center",children:"PV"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2020.05.01"}),(0,i.jsx)(t.td,{align:"center",children:"CHN"}),(0,i.jsx)(t.td,{align:"center",children:"3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2020.05.01"}),(0,i.jsx)(t.td,{align:"center",children:"USA"}),(0,i.jsx)(t.td,{align:"center",children:"7"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"how-to-use-aggregation-model",children:"How to use aggregation model"}),"\n",(0,i.jsxs)(t.p,{children:["When creating a table, the aggregation model is enabled by specifying the aggregation function for the value column. Users can use the ",(0,i.jsx)(t.code,{children:"AGGREGATE KEY"})," to define the sort key."]}),"\n",(0,i.jsx)(t.p,{children:"The following is an example of creating a data table using the aggregation model."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"site_id"}),", ",(0,i.jsx)(t.code,{children:"date"})," and ",(0,i.jsx)(t.code,{children:"city_code"})," are sort keys;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pv"})," is the value column, using the aggregation function ",(0,i.jsx)(t.code,{children:"SUM"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.aggregate_tbl (\n site_id LARGEINT NOT NULL COMMENT "id of site",\n date DATE NOT NULL COMMENT "time of event",\n city_code VARCHAR(20) COMMENT "city_code of user"\n pv BIGINT SUM DEFAULT "0" COMMENT "total page views"\n)\nDISTRIBUTED BY HASH(site_id) BUCKETS 8;\n'})}),"\n",(0,i.jsx)(t.h3,{id:"notes-on-aggregation-model",children:"Notes on aggregation model"}),"\n",(0,i.jsx)(t.p,{children:"The data in the aggregation table will be imported in batches several times, and each import is a new data version. There are three triggers for aggregation:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"When the data is imported, aggregation is performed before the data is spilled to disk."}),"\n",(0,i.jsx)(t.li,{children:"After the data is spilled to disk, asynchronous aggregation of multiple versions is performed in the background ;"}),"\n",(0,i.jsx)(t.li,{children:"Multi-version multi-way aggregation is performed during the query."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"During the query, the value columns are aggregated first and then filtered, and the filtered columns are stored as key  columns."}),"\n",(0,i.jsx)(t.p,{children:'Refer to "Create Table Statement" for the list of aggregation functions supported by the aggregation model.'}),"\n",(0,i.jsx)(t.h2,{id:"update-model",children:"Update model"}),"\n",(0,i.jsx)(t.h3,{id:"scenarios-for-update-model",children:"Scenarios for update model"}),"\n",(0,i.jsx)(t.p,{children:"Update model is tailored to the scenarios where data gets constantly updated. For example, in an e-commerce scenario, the status of an order often changes, and the number of order updates can exceed hundreds of millions per day. Using the duplicate model to delete old data and insert new data can barely meet the frequent update requirements. The update model is designed for such scenarios. Its suitable scenarios has the following characteristics:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"There is a demand for constantly updating a large amount of data."}),"\n",(0,i.jsx)(t.li,{children:"Real-time data analysis is required."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"principle-of-update-model",children:"Principle of update model"}),"\n",(0,i.jsx)(t.p,{children:"In the update model, the sort key satisfies the uniqueness constraint and is the primary key."}),"\n",(0,i.jsx)(t.p,{children:"The StarRocks internally assigns a version number to each batch of imported data. There may be more than one version of the same primary key. When querying, it returns the largest (latest) version of the data."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{align:"center",children:"ID"}),(0,i.jsx)(t.th,{align:"center",children:"value"}),(0,i.jsx)(t.th,{align:"center",children:"_version"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"1"}),(0,i.jsx)(t.td,{align:"center",children:"100"}),(0,i.jsx)(t.td,{align:"center",children:"1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"1"}),(0,i.jsx)(t.td,{align:"center",children:"101"}),(0,i.jsx)(t.td,{align:"center",children:"2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2"}),(0,i.jsx)(t.td,{align:"center",children:"100"}),(0,i.jsx)(t.td,{align:"center",children:"3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2"}),(0,i.jsx)(t.td,{align:"center",children:"101"}),(0,i.jsx)(t.td,{align:"center",children:"4"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2"}),(0,i.jsx)(t.td,{align:"center",children:"102"}),(0,i.jsx)(t.td,{align:"center",children:"5"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["As shown in the example above, ",(0,i.jsx)(t.code,{children:"ID"})," is the primary key, ",(0,i.jsx)(t.code,{children:"value"})," is the content, and",(0,i.jsx)(t.code,{children:"__version"})," is the internal version number. The data with ",(0,i.jsx)(t.code,{children:"ID=1"})," has two import batches, version 1 and 2 respectively.  The data with ",(0,i.jsx)(t.code,{children:"ID=2"})," has three import batches, version 3, 4 and 5 respectively. When querying, only the data of the latest version will return (as shown as follow):"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{align:"center",children:"ID"}),(0,i.jsx)(t.th,{align:"center",children:"value"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"1"}),(0,i.jsx)(t.td,{align:"center",children:"101"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{align:"center",children:"2"}),(0,i.jsx)(t.td,{align:"center",children:"102"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Through this mechanism, StarRocks can support the analysis of frequently updated data."}),"\n",(0,i.jsx)(t.h3,{id:"how-to-use-update-model",children:"How to use update model"}),"\n",(0,i.jsxs)(t.p,{children:["In e-commerce scenarios, statistical analysis is often based on order status. Although the order status changes frequently, ",(0,i.jsx)(t.code,{children:"create_time"})," and ",(0,i.jsx)(t.code,{children:"order_id"})," do not change and therefore are often used as filter conditions in queries. Users set the ",(0,i.jsx)(t.code,{children:"create_time"})," and ",(0,i.jsx)(t.code,{children:"order_id"})," columns as primary keys(i.e., defined with the ",(0,i.jsx)(t.code,{children:"UNIQUE KEY"})," keyword when creating a table), which meet the demand for order status updates and allow for quick filtering in queries."]}),"\n",(0,i.jsx)(t.p,{children:"The following is an example of creating a data table using the update model."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"UNIQUE KEY"}),"(",(0,i.jsx)(t.code,{children:"create_time"}),", ",(0,i.jsx)(t.code,{children:"order_id"}),") as the primary key, where ",(0,i.jsx)(t.code,{children:"create_time"})," and",(0,i.jsx)(t.code,{children:"order_id"})," are in the queue, and their definitions appear before the definitions of other columns;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"order_state"})," and ",(0,i.jsx)(t.code,{children:"total_price"})," are value columns, and their aggregation type is ",(0,i.jsx)(t.code,{children:"REPLACE"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS detail (\n create_time DATE NOT NULL COMMENT "create time of an order",\n order_id BIGINT NOT NULL COMMENT "id of an order",\n order_state INT COMMENT "state of an order",\n total_price BIGINT COMMENT "price of an order"\n)\nUNIQUE KEY(create_time, order_id)\nDISTRIBUTED BY HASH(order_id) BUCKETS 8\n'})}),"\n",(0,i.jsx)(t.h3,{id:"notes-on-update-model",children:"Notes on update model"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["When importing data, you need to complete all fields, i.e., ",(0,i.jsx)(t.code,{children:"create_time"}),", ",(0,i.jsx)(t.code,{children:"order_id"}),", ",(0,i.jsx)(t.code,{children:"order_state"})," and ",(0,i.jsx)(t.code,{children:"total_price"})," in the above example."]}),"\n",(0,i.jsx)(t.li,{children:"When reading data in an update model, multiple versions need to be merged during the query. Given the large number of versions the query performance will be degraded. Therefore, you should reduce the frequency of importing data to an update model. The import frequency should be designed to meet the business requirements for real-time performance."}),"\n",(0,i.jsx)(t.li,{children:"When querying, filtering is usually performed after multiple versions are merged. To improve query performance, place the value columns that are often filtered but not modified on the primary key. During merging, all primary keys will be compared. For better performance, users should avoid defining too many primary keys. If a column is only occasionally present as a filter condition, it does not need to be placed in the primary key."}),"\n"]})]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(c,e)})):c(e)}},11151:(e,t,n)=>{n.d(t,{Zo:()=>s,ah:()=>a});var i=n(67294);const r=i.createContext({});function a(e){const t=i.useContext(r);return i.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const d={};function s({components:e,children:t,disableParentContext:n}){let s;return s=n?"function"==typeof e?e({}):e||d:a(e),i.createElement(r.Provider,{value:s},t)}}}]);