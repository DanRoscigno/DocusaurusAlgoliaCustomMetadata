"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[10572],{81500:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=n(85893),a=n(11151);const s={displayed_sidebar:"English"},r="Data distribution",o={id:"table_design/Data_distribution",title:"Data distribution",description:"Technical terms",source:"@site/versioned_docs/version-2.1/table_design/Data_distribution.md",sourceDirName:"table_design",slug:"/table_design/Data_distribution",permalink:"/docs/2.1/table_design/Data_distribution",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/table_design/Data_distribution.md",tags:[],version:"2.1",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"Bloom Filter Indexing",permalink:"/docs/2.1/table_design/Bloomfilter_index"},next:{title:"Data Models",permalink:"/docs/2.1/table_design/Data_model"}},d={},c=[{value:"Technical terms",id:"technical-terms",level:2},{value:"Data distribution overview",id:"data-distribution-overview",level:2},{value:"StarRocks Data Distribution",id:"starrocks-data-distribution",level:2},{value:"Data Distribution Method",id:"data-distribution-method",level:3},{value:"How to select partition key",id:"how-to-select-partition-key",level:3},{value:"How to choose the bucket key",id:"how-to-choose-the-bucket-key",level:3},{value:"How to determine the number of buckets",id:"how-to-determine-the-number-of-buckets",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Dynamic Partition Management",id:"dynamic-partition-management",level:2},{value:"Creating a table that supports dynamic partitioning",id:"creating-a-table-that-supports-dynamic-partitioning",level:3},{value:"View the current partition of the table",id:"view-the-current-partition-of-the-table",level:3},{value:"Modify the partitioning attributes of a table",id:"modify-the-partitioning-attributes-of-a-table",level:3},{value:"Caution",id:"caution",level:3},{value:"Create and modify partitions in bulk",id:"create-and-modify-partitions-in-bulk",level:2},{value:"Create date partitions in bulk during table creation",id:"create-date-partitions-in-bulk-during-table-creation",level:3},{value:"Create numeric partitions in bulk during table creation",id:"create-numeric-partitions-in-bulk-during-table-creation",level:3},{value:"Create different types of date partitions in bulk during table creation",id:"create-different-types-of-date-partitions-in-bulk-during-table-creation",level:3},{value:"Create partitions in bulk after table being created",id:"create-partitions-in-bulk-after-table-being-created",level:3}];function l(e){const t=Object.assign({h1:"h1",h2:"h2",ul:"ul",li:"li",strong:"strong",p:"p",img:"img",h3:"h3",pre:"pre",code:"code",br:"br"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"data-distribution",children:"Data distribution"}),"\n",(0,i.jsx)(t.h2,{id:"technical-terms",children:"Technical terms"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Data distribution"}),": Data distribution aims to evenly distribute data on different nodes according to certain rules, to optimize the concurrency performance of the cluster."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Short-scan query"}),": Short-scan query, refers to the query that scans a small amount of data, and can be completed by a single machine."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"long-scan query"}),": Long-scan query, refers to the query that scans a large amount of data, and can be completed by multiple machines in parallel to significantly improve performance."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"data-distribution-overview",children:"Data distribution overview"}),"\n",(0,i.jsx)(t.p,{children:"The four common types of data distribution are (a) Round-Robin, (b) Range, (c) List, and (d) Hash (DeWitt and Gray, 1992). As the Exmaple below shows:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Data distribution method",src:n(14581).Z+"",width:"1599",height:"1503"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Round-Robin"})," : Places the data on adjacent nodes one by one in a rotating manner."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Range"})," : Distributes the data by intervals. The intervals [1-3], [4-6] in the Exmaple correspond to different Ranges respectively."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"List"})," : Distributes the data based on discrete individual values (e.g. gender, province). Each discrete value will be mapped to a node, and different fetch values may also be mapped to the same node."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Hash"})," : Maps data to different nodes by hash function."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"To divide data more flexibly, modern distributed databases may \u201cmix-and-match\u201d the four data distribution methods for some use cases. The common combination methods are Hash-Hash, Range-Hash, and Hash-List."}),"\n",(0,i.jsx)(t.h2,{id:"starrocks-data-distribution",children:"StarRocks Data Distribution"}),"\n",(0,i.jsx)(t.h3,{id:"data-distribution-method",children:"Data Distribution Method"}),"\n",(0,i.jsx)(t.p,{children:"StarRocks uses partitioning followed by bucketing to support two types of distribution:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Hash distribution: The entire table is treated as a partition, and the number of buckets is specified."}),"\n",(0,i.jsx)(t.li,{children:"Range-Hash distribution: Specify the number of partitions and the number of buckets for each partition."}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"-- Table creation statements using Hash distribution\nCREATE TABLE site_access(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT SUM DEFAULT '0'\n)\nAGGREGATE KEY(site_id, city_code, user_name)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n"})}),"\n",(0,i.jsx)(t.p,{children:":-: Exmaple 3.2\uff1aTable creation statements using hash distribution"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"-- Table creation statement using Range-Hash distribution\nCREATE TABLE site_access(\nevent_day DATE,\nsite_id INT DEFAULT '10',\ncity_code VARCHAR(100),\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT SUM DEFAULT '0'\n)\nAGGREGATE KEY(event_day, site_id, city_code, user_name)\nPARTITION BY RANGE(event_day)\n(\nPARTITION p1 VALUES LESS THAN ('2020-01-31'),\nPARTITION p2 VALUES LESS THAN ('2020-02-29'),\nPARTITION p3 VALUES LESS THAN ('2020-03-31')\n)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10;\n"})}),"\n",(0,i.jsx)(t.p,{children:":-: Exmaple 3.3\uff1aTable creation statement using Range-Hash  distribution"}),"\n",(0,i.jsxs)(t.p,{children:["Range distribution is known as partitioning. The column used for partitioning is called partition column. The ",(0,i.jsx)(t.code,{children:"event_day"})," in Exmaple 3.3 is the partition column. Hash distribution is known as bucketing. The column used for bucketing is called bucket column. The bucket column in Exmaple 3.2 and 3.3 is ",(0,i.jsx)(t.code,{children:"site_id"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Range partitions can be dynamically added and deleted. In Exmaple 3.3, if new data comes in that belongs to a new month, users can add a new partition. Once determined, the number of buckets cannot be adjusted."}),"\n",(0,i.jsx)(t.p,{children:"When using the Range-Hash distribution method, by default, the newly created partition has the same number of buckets as the original partition. Users can adjust the number of buckets according to the data size. The following Exmaple shows an example of adding a partition to the above table with a new number of buckets."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'ALTER TABLE site_access\nADD PARTITION p4 VALUES LESS THAN ("2020-04-31")\nDISTRIBUTED BY HASH(site_id) BUCKETS 20;\n'})}),"\n",(0,i.jsx)(t.p,{children:"-: Exmaple 3.4\uff1aAdd a new partition to the site_access table with a new number of buckets"}),"\n",(0,i.jsx)(t.h3,{id:"how-to-select-partition-key",children:"How to select partition key"}),"\n",(0,i.jsx)(t.p,{children:"Each partition is a management unit that follows storage policies such as number of replications, hot/cold policy, storage media, etc. In most cases, the most recent data is more likely to be queried. To optimize query performance, users can leverage StarRocks\u2019s partition trimming feature and place the most recent data within a partition to minimize the amount of data for scanning. Also, StarRocks supports using multiple storage media (SATA/SSD) within a cluster. Users can put the partition where the latest data is located on SSDs and take advantage of SSD's random read/write feature to improve query performance. The historical data can be put on a SATA disk to save the cost of data storage."}),"\n",(0,i.jsx)(t.p,{children:"In most cases, users select the time column as the partition key, and set the number of partitions based on the data volume. The original data volume of a single partition is recommended to be maintained within 100G."}),"\n",(0,i.jsx)(t.h3,{id:"how-to-choose-the-bucket-key",children:"How to choose the bucket key"}),"\n",(0,i.jsx)(t.p,{children:"StarRocks uses the hash algorithm as the bucketing algorithm. Within the same partition, data with the same bucket key value forms sub-tables (tablets). Tablet replicas are physically managed by separate local storage engines. Data import and query take place in tablet replicas. Tablets are the basic unit of data balancing and recovery."}),"\n",(0,i.jsxs)(t.p,{children:["In Exmaple 3.2, ",(0,i.jsx)(t.code,{children:"site_access"})," uses ",(0,i.jsx)(t.code,{children:"site_id"})," as the bucketing key because query requests use ",(0,i.jsx)(t.code,{children:"site"})," as the filter. By using ",(0,i.jsx)(t.code,{children:"site_id"})," as the bucketing key, a large number of irrelevant buckets can be trimmed off during querying. In the query in Exmaple 3.5 below, 9 out of 10 buckets can be trimmed off, and only 1/10 of the table ",(0,i.jsx)(t.code,{children:"site_access"})," needs to be scanned."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"select\ncity_code, sum(pv)\nfrom site_access\nwhere site_id = 54321;\n"})}),"\n",(0,i.jsx)(t.p,{children:":-: Exmaple 3.5: a query against table site_access"}),"\n",(0,i.jsxs)(t.p,{children:["However, there is a situation where the ",(0,i.jsx)(t.code,{children:"site_id"})," distribution is assumed to be very uneven, that is,  a large amount of data comes from  a small number of  sites (power-law distribution, Pareto principle). If the user still uses the above bucketing method, the data distribution will be severely skewed, leading to local performance bottlenecks in the system. At this point, users need to adjust the bucket key to break up the data and avoid performance problems. In Exmaple 5 below, the combination of ",(0,i.jsx)(t.code,{children:"site_id"})," and ",(0,i.jsx)(t.code,{children:"city_code"})," can be used as the bucket key to divide the data more evenly."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"CREATE TABLE site_access\n(\nsite_id INT DEFAULT '10',\ncity_code SMALLINT,\nuser_name VARCHAR(32) DEFAULT '',\npv BIGINT SUM DEFAULT '0'\n)\nAGGREGATE KEY(site_id, city_code, user_name)\nDISTRIBUTED BY HASH(site_id,city_code) BUCKETS 10;\n"})}),"\n",(0,i.jsx)(t.p,{children:":-: Exmaple 3.6: Using site_id, city_code as bucketing keys"}),"\n",(0,i.jsxs)(t.p,{children:["Using ",(0,i.jsx)(t.code,{children:"site_id"})," as the bucking key is good for short queries. It reduces the data exchange between nodes and improves the overall performance of the cluster. Using the combination of ",(0,i.jsx)(t.code,{children:"site_id"})," and ",(0,i.jsx)(t.code,{children:"city_code"})," as the bucketing key is good for long queries.  It takes advantage of the overall concurrency performance of the distributed cluster and Increases the throughput. Users choose the method that suits best to their use case."]}),"\n",(0,i.jsx)(t.h3,{id:"how-to-determine-the-number-of-buckets",children:"How to determine the number of buckets"}),"\n",(0,i.jsx)(t.p,{children:"In a StarRocks system, a partitioned bucket is a unit of actual physical file organization. After the data is written to disk, it will involve the management of disk files. Generally speaking, we do not recommend setting the buckets number too big or too small, it is more appropriate to try to be moderate."}),"\n",(0,i.jsx)(t.p,{children:"As a rule of thumb, it is not recommended to have more than 10G per bucket, where 10G refers to the original data. Considering the compression ratio, the file size of each bucket on disk after compression is around 4~5G, which is sufficient to meet business needs in most cases."}),"\n",(0,i.jsx)(t.p,{children:"Users are recommended to adjust the number of buckets when building tables according to the change of cluster size. The change of cluster size mainly refers to the change of the number of nodes. Suppose there are 100G of raw data, according to the above criteria, 10 buckets can be built. However, if the user has 20 machines, then the amount of data per bucket can be reduced and the number of buckets can be increased."}),"\n",(0,i.jsx)(t.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(t.p,{children:["When using StarRocks, the choice of partitioning and bucketing is very critical. Choosing a suitable partition key and bucket key when creating tables can effectively improve the overall performance of the cluster.",(0,i.jsx)(t.br,{}),"\n","Here are some suggestions for partitioning and bucketing selection in special application scenarios."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Data skew"}),": If the data is skewed, instead of using only one column, we recommend using a combination of multiple columns for data partitioning and bucketing."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"High Concurrency"}),": Partitioning and bucketing should meet the query requirements at its best, which can effectively reduce the amount of data for scanning and improve concurrency."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"High Throughput"}),": Break up the data to allow the cluster to scan the data with higher concurrency and complete the corresponding computation."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"dynamic-partition-management",children:"Dynamic Partition Management"}),"\n",(0,i.jsx)(t.p,{children:"In real-world scenarios, the timeliness of data is important. New partitions need to be created, and expired partitions need to be deleted. StarRocks's dynamic partitioning mechanism enables partition rollover. StarRocks provides Time to Live (TTL) management to automatically add or delete partitions."}),"\n",(0,i.jsx)(t.h3,{id:"creating-a-table-that-supports-dynamic-partitioning",children:"Creating a table that supports dynamic partitioning"}),"\n",(0,i.jsx)(t.p,{children:"The following example shows the setup of dynamic partitioning."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'CREATE TABLE site_access(\nevent_day DATE,\nsite_id INT DEFAULT \'10\',\ncity_code VARCHAR(100),\nuser_name VARCHAR(32) DEFAULT \'\',\npv BIGINT DEFAULT \'0\'\n)\nDUPLICATE KEY(event_day, site_id, city_code, user_name)\nPARTITION BY RANGE(event_day)(\nPARTITION p20200321 VALUES LESS THAN ("2020-03-22"),\nPARTITION p20200322 VALUES LESS THAN ("2020-03-23"),\nPARTITION p20200323 VALUES LESS THAN ("2020-03-24"),\nPARTITION p20200324 VALUES LESS THAN ("2020-03-25")\n)\nDISTRIBUTED BY HASH(event_day, site_id) BUCKETS 32\nPROPERTIES(\n"dynamic_partition.enable" = "true",\n"dynamic_partition.time_unit" = "DAY",\n"dynamic_partition.start" = "-3",\n"dynamic_partition.end" = "3",\n"dynamic_partition.prefix" = "p",\n"dynamic_partition.buckets" = "32"\n);\n'})}),"\n",(0,i.jsx)(t.p,{children:":-: Example 4.1: Tables in dynamic partitioning"}),"\n",(0,i.jsxs)(t.p,{children:["To configure the dynamic partitioning policy, specify ",(0,i.jsx)(t.code,{children:"PEROPERTIES"})," in the table creation statement in example 4.1. The configuration items can be described as follows."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["dynamic_partition.enable: To enable dynamic partitioning, set it as ",(0,i.jsx)(t.code,{children:"TRUE"}),". Otherwise, set it as ",(0,i.jsx)(t.code,{children:"FALSE"}),". The default is ",(0,i.jsx)(t.code,{children:"TRUE"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["dynamic_partition.time_unit : The granularity of dynamic partition scheduling, specified as ",(0,i.jsx)(t.code,{children:"DAY"}),"/",(0,i.jsx)(t.code,{children:"WEEK"}),"/",(0,i.jsx)(t.code,{children:"MONTH"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Exmaple 1 shows an example of a partition by ",(0,i.jsx)(t.code,{children:"day"}),", where the partition name suffix satisfies ",(0,i.jsx)(t.code,{children:"yyyyMMdd"}),', e.g., 2030325.\nPARTITION p20200321 VALUES LESS THAN ("2020-03-22"),\nPARTITION p20200322 VALUES LESS THAN ("2020-03-23"),\nPARTITION p20200323 VALUES LESS THAN ("2020-03-24"),\nPARTITION p20200324 VALUES LESS THAN ("2020-03-25")']}),"\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"WEEK"})," is specified, the partition name is created with the suffix format  ",(0,i.jsx)(t.code,{children:"yyyy_ww"}),", e.g. 2020_13"]}),"\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"MONTH"})," is specified, the partition name is created with the suffix format ",(0,i.jsx)(t.code,{children:"yyyyMM"}),", e.g. 202003."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["dynamic_partition.start: The start time of the dynamic partition. Based on the day, partitions that exceed this time range will be deleted. If not filled, it defaults to ",(0,i.jsx)(t.code,{children:"Integer.MIN\\_VALUE"})," i.e. -2147483648."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"dynamic_partition.end: The end time of the dynamic partition. A partition range of N units will be created ahead of time, based on the day."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"dynamic_partition.prefix: The prefix of the dynamically created partition name."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"dynamic_partition.buckets: The number of buckets corresponding to the dynamically created partition."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In Exmaple 4.1, a table is created with  dynamic partitioning enabled simultaneously. The interval of partitioning is 3 days before and after the current time (6 days in total). Assuming the current time is 2020-03-25, at each scheduling, partitions with upper bound less than 2020-03-22 will be deleted, and partitions for the next 3 days will be created at the same time. Once the scheduling is complete, new partitions will be shown as follows."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"[types: [DATE]; keys: [2020-03-22]; \u2025types: [DATE]; keys: [2020-03-23]; )\n[types: [DATE]; keys: [2020-03-23]; \u2025types: [DATE]; keys: [2020-03-24]; )\n[types: [DATE]; keys: [2020-03-24]; \u2025types: [DATE]; keys: [2020-03-25]; )\n[types: [DATE]; keys: [2020-03-25]; \u2025types: [DATE]; keys: [2020-03-26]; )\n[types: [DATE]; keys: [2020-03-26]; \u2025types: [DATE]; keys: [2020-03-27]; )\n[types: [DATE]; keys: [2020-03-27]; \u2025types: [DATE]; keys: [2020-03-28]; )\n[types: [DATE]; keys: [2020-03-28]; \u2025types: [DATE]; keys: [2020-03-29]; )\n"})}),"\n",(0,i.jsx)(t.p,{children:":-: Exmaple 4.2: Partitioning of a table being automatically add/delete partitions"}),"\n",(0,i.jsxs)(t.p,{children:["The scheduling depends on the FE configuration whose resident threads are controlled by the parameters ",(0,i.jsx)(t.code,{children:"dynamic_partition_enable"})," and ",(0,i.jsx)(t.code,{children:"dynamic_partition_check_interval_seconds"}),". Each time it is scheduled, it reads the properties of the dynamic partitioning table to determine whether to add or delete partitions."]}),"\n",(0,i.jsx)(t.h3,{id:"view-the-current-partition-of-the-table",children:"View the current partition of the table"}),"\n",(0,i.jsx)(t.p,{children:"When a dynamic partitioning table operates, partitions are added and deleted automatically. You can check the current partitioning status by the following command."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"SHOW PARTITIONS FROM site_access;\n"})}),"\n",(0,i.jsx)(t.p,{children:":-: Exmaple 4.3 : site_access current partition"}),"\n",(0,i.jsx)(t.h3,{id:"modify-the-partitioning-attributes-of-a-table",children:"Modify the partitioning attributes of a table"}),"\n",(0,i.jsxs)(t.p,{children:["The attributes of dynamic partitioning can be modified. If you need to start or stop dynamic partitioning, you can do so by ",(0,i.jsx)(t.code,{children:"ALTER TABLE"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'ALTER TABLE site_access SET("dynamic_partition.enable"="false");\nALTER TABLE site_access SET("dynamic_partition.enable"="true");\n'})}),"\n",(0,i.jsx)(t.p,{children:"Note: Similarly, you can also modify other properties accordingly."}),"\n",(0,i.jsx)(t.h3,{id:"caution",children:"Caution"}),"\n",(0,i.jsx)(t.p,{children:"The dynamic partitioning approach relies on StarRocks to logically manage partitions. It is important to make sure that the partition name meets the requirements, otherwise it will fail to be created. The requirements are as follows."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"DAY"})," is specified, the partition name should be suffixed with ",(0,i.jsx)(t.code,{children:"yyyyMMdd"}),", e.g., 2030325."]}),"\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"WEEK"})," is specified, the partition name should be suffixed with ",(0,i.jsx)(t.code,{children:"yyyy\\_ww"}),", e.g. 2020_13, for the 13th week of 2020."]}),"\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"MONTH"})," is specified, the partition name should be suffixed with ",(0,i.jsx)(t.code,{children:"yyyyMM"}),", e.g. 202003."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"create-and-modify-partitions-in-bulk",children:"Create and modify partitions in bulk"}),"\n",(0,i.jsx)(t.h3,{id:"create-date-partitions-in-bulk-during-table-creation",children:"Create date partitions in bulk during table creation"}),"\n",(0,i.jsxs)(t.p,{children:["Users can create partitions in bulk by giving a ",(0,i.jsx)(t.code,{children:"START"})," value, an ",(0,i.jsx)(t.code,{children:"END"})," value and an ",(0,i.jsx)(t.code,{children:"EVERY"})," clause defining the incremental value of the partitions."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"START"})," value will be included whereas the ",(0,i.jsx)(t.code,{children:"END"})," value will be excluded."]}),"\n",(0,i.jsx)(t.p,{children:"For example."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'CREATE TABLE site_access (\n datekey DATE,\n site_id INT,\n city_code SMALLINT,\n user_name VARCHAR(32),\n pv BIGINT DEFAULT \'0\'\n)\nENGINE=olap\nDUPLICATE KEY(datekey, site_id, city_code, user_name)\nPARTITION BY RANGE (datekey) (\n START ("2021-01-01") END ("2021-01-04") EVERY (INTERVAL 1 day)\n)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10\nPROPERTIES (\n "replication_num" = "1"\n);\n'})}),"\n",(0,i.jsx)(t.p,{children:"StarRocks will automatically create the equivalent partitions as follows:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-TEXT",children:"PARTITION p20210101 VALUES [('2021-01-01'), ('2021-01-02')),\nPARTITION p20210102 VALUES [('2021-01-02'), ('2021-01-03')),\nPARTITION p20210103 VALUES [('2021-01-03'), ('2021-01-04'))\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Currently, the partition key only supports date type and integer type. The partition type needs to match the expression in ",(0,i.jsx)(t.code,{children:"EVERY"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["When the partition key is a date type, you need to specify the ",(0,i.jsx)(t.code,{children:"INTERVAL"})," keyword to indicate the date interval. Currently, the supported keywords are",(0,i.jsx)(t.code,{children:"day"}),", ",(0,i.jsx)(t.code,{children:"week"}),", ",(0,i.jsx)(t.code,{children:"month"}),", and ",(0,i.jsx)(t.code,{children:"year"}),". The partition naming conventions are the same as the ones of dynamic partitioning."]}),"\n",(0,i.jsx)(t.h3,{id:"create-numeric-partitions-in-bulk-during-table-creation",children:"Create numeric partitions in bulk during table creation"}),"\n",(0,i.jsxs)(t.p,{children:["When the partition key is an integer type, numbers are used to perform the partition. Note that partition values need to be quoted in quotes, while ",(0,i.jsx)(t.code,{children:"EVERY"})," does not need to be quoted. For example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'CREATE TABLE site_access (\n datekey INT,\n site_id INT,\n city_code SMALLINT,\n user_name VARCHAR(32),\n pv BIGINT DEFAULT \'0\'\n)\nENGINE=olap\nDUPLICATE KEY(datekey, site_id, city_code, user_name)\nPARTITION BY RANGE (datekey) (\n START ("1") END ("5") EVERY (1)\n)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10\nPROPERTIES (\n "replication_num" = "1"\n);\n'})}),"\n",(0,i.jsx)(t.p,{children:"The above statement will produce the following partitions:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'PARTITION p1 VALUES [("1"), ("2")),\nPARTITION p2 VALUES [("2"), ("3")),\nPARTITION p3 VALUES [("3"), ("4")),\nPARTITION p4 VALUES [("4"), ("5"))\n'})}),"\n",(0,i.jsx)(t.h3,{id:"create-different-types-of-date-partitions-in-bulk-during-table-creation",children:"Create different types of date partitions in bulk during table creation"}),"\n",(0,i.jsx)(t.p,{children:"StarRocks also supports defining different types of partitions at the same time when creating a table, as long as these partitions do not intersect. For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'CREATE TABLE site_access (\n datekey DATE,\n site_id INT,\n city_code SMALLINT,\n user_name VARCHAR(32),\n pv BIGINT DEFAULT \'0\'\n)\nENGINE=olap\nDUPLICATE KEY(datekey, site_id, city_code, user_name)\nPARTITION BY RANGE (datekey) (\n START ("2019-01-01") END ("2021-01-01") EVERY (INTERVAL 1 YEAR),\n START ("2021-01-01") END ("2021-05-01") EVERY (INTERVAL 1 MONTH),\n START ("2021-05-01") END ("2021-05-04") EVERY (INTERVAL 1 DAY)\n)\nDISTRIBUTED BY HASH(site_id) BUCKETS 10\nPROPERTIES (\n "replication_num" = "1"\n);\n \n'})}),"\n",(0,i.jsx)(t.p,{children:"The above statement will produce the following partitions:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-TEXT",children:"PARTITION p2019 VALUES [('2019-01-01'), ('2020-01-01')),\nPARTITION p2020 VALUES [('2020-01-01'), ('2021-01-01')),\nPARTITION p202101 VALUES [('2021-01-01'), ('2021-02-01')),\nPARTITION p202102 VALUES [('2021-02-01'), ('2021-03-01')),\nPARTITION p202103 VALUES [('2021-03-01'), ('2021-04-01')),\nPARTITION p202104 VALUES [('2021-04-01'), ('2021-05-01')),\nPARTITION p20210501 VALUES [('2021-05-01'), ('2021-05-02')),\nPARTITION p20210502 VALUES [('2021-05-02'), ('2021-05-03')),\nPARTITION p20210503 VALUES [('2021-05-03'), ('2021-05-04'))\n"})}),"\n",(0,i.jsx)(t.h3,{id:"create-partitions-in-bulk-after-table-being-created",children:"Create partitions in bulk after table being created"}),"\n",(0,i.jsxs)(t.p,{children:["Similar to bulk partition creation during table creation, StarRocks also supports bulk partition creation via ",(0,i.jsx)(t.code,{children:"ALTER"})," statement. Partitions are created by specifying the ",(0,i.jsx)(t.code,{children:"ADD PARITIONS"})," keyword with the ",(0,i.jsx)(t.code,{children:"START"}),", ",(0,i.jsx)(t.code,{children:"END"})," and ",(0,i.jsx)(t.code,{children:"EVERY"})," values."]})]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(l,e)})):l(e)}},14581:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/3.3.2-1-0155848c9c26956ba951ea54de8194f7.png"},11151:(e,t,n)=>{n.d(t,{Zo:()=>o,ah:()=>s});var i=n(67294);const a=i.createContext({});function s(e){const t=i.useContext(a);return i.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const r={};function o({components:e,children:t,disableParentContext:n}){let o;return o=n?"function"==typeof e?e({}):e||r:s(e),i.createElement(a.Provider,{value:o},t)}}}]);