"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[73460],{41508:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var r=s(85893),i=s(11151);const l={displayed_sidebar:"documentation"},t="Window function",a={id:"sql-reference/sql-functions/Window_function",title:"Window function",description:"Background",source:"@site/versioned_docs/version-3.1/sql-reference/sql-functions/Window_function.md",sourceDirName:"sql-reference/sql-functions",slug:"/sql-reference/sql-functions/Window_function",permalink:"/doc/docs/sql-reference/sql-functions/Window_function",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/tree/main/versioned_docs/version-3.1/sql-reference/sql-functions/Window_function.md",tags:[],version:"3.1",frontMatter:{displayed_sidebar:"documentation"},sidebar:"documentation",previous:{title:"Java UDFs",permalink:"/doc/docs/sql-reference/sql-functions/JAVA_UDF"},next:{title:"Lambda expression",permalink:"/doc/docs/sql-reference/sql-functions/Lambda_expression"}},o={},c=[{value:"Background",id:"background",level:2},{value:"Usage",id:"usage",level:2},{value:"Functions",id:"functions",level:3},{value:"PARTITION BY clause",id:"partition-by-clause",level:3},{value:"ORDER BY clause",id:"order-by-clause",level:3},{value:"Window clause",id:"window-clause",level:3},{value:"Function Examples",id:"function-examples",level:2},{value:"AVG()",id:"avg",level:3},{value:"COUNT()",id:"count",level:3},{value:"CUME_DIST()",id:"cume_dist",level:3},{value:"DENSE_RANK()",id:"dense_rank",level:3},{value:"NTILE()",id:"ntile",level:3},{value:"FIRST_VALUE()",id:"first_value",level:3},{value:"LAG()",id:"lag",level:3},{value:"LAST_VALUE()",id:"last_value",level:3},{value:"LEAD()",id:"lead",level:3},{value:"MAX()",id:"max",level:3},{value:"MIN()",id:"min",level:3},{value:"PERCENT_RANK()",id:"percent_rank",level:3},{value:"RANK()",id:"rank",level:3},{value:"ROW_NUMBER()",id:"row_number",level:3},{value:"QUALIFY()",id:"qualify",level:3},{value:"SUM()",id:"sum",level:3},{value:"VARIANCE, VAR_POP, VARIANCE_POP",id:"variance-var_pop-variance_pop",level:3},{value:"VAR_SAMP, VARIANCE_SAMP",id:"var_samp-variance_samp",level:3},{value:"STD, STDDEV, STDDEV_POP",id:"std-stddev-stddev_pop",level:3},{value:"STDDEV_SAMP",id:"stddev_samp",level:3},{value:"COVAR_SAMP",id:"covar_samp",level:3},{value:"COVAR_POP",id:"covar_pop",level:3},{value:"CORR",id:"corr",level:3}];function d(e){const n=Object.assign({h1:"h1",h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre",h3:"h3",ul:"ul",li:"li",a:"a",blockquote:"blockquote",ol:"ol"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"window-function",children:"Window function"}),"\n",(0,r.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,r.jsxs)(n.p,{children:['The window function is a special class of built-in functions. Similar to the aggregation function, it also does calculations on multiple input rows to get a single data value. The difference is that the window function processes the input data within a specific window, rather than using the "group by" method. The data in each window can be sorted and grouped using the over() clause. The window function ',(0,r.jsx)(n.strong,{children:"computes a separate value for each row"}),", rather than computing one value for each group. This flexibility allows users to add additional columns to the select clause and further filter the result set. The window function can only appear in the select list and the outermost position of a clause. It takes effect at the end of the query, that is, after the ",(0,r.jsx)(n.code,{children:"join"}),", ",(0,r.jsx)(n.code,{children:"where"}),", and ",(0,r.jsx)(n.code,{children:"group by"})," operations are performed. The window function is often used to analyze trends, calculate outliers, and perform bucketing analyses on large-scale data."]}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.p,{children:"Syntax of the window function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"function(args) OVER(partition_by_clause order_by_clause [window_clause])\npartition_by_clause ::= PARTITION BY expr [, expr ...]\norder_by_clause ::= ORDER BY expr [ASC | DESC] [, expr [ASC | DESC] ...]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,r.jsx)(n.p,{children:"Currently supported functions include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"MIN(), MAX(), COUNT(), SUM(), AVG()"}),"\n",(0,r.jsx)(n.li,{children:"FIRST_VALUE(), LAST_VALUE(), LEAD(), LAG()"}),"\n",(0,r.jsx)(n.li,{children:"ROW_NUMBER(), RANK(), DENSE_RANK()"}),"\n",(0,r.jsx)(n.li,{children:"CUME_DIST(), PERCENT_RANK(), QUALIFY()"}),"\n",(0,r.jsx)(n.li,{children:"NTILE()"}),"\n",(0,r.jsx)(n.li,{children:"VARIANCE(), VAR_SAMP(), STD(), STDDEV_SAMP(), COVAR_SAMP(), COVAR_POP(), CORR()"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"partition-by-clause",children:"PARTITION BY clause"}),"\n",(0,r.jsx)(n.p,{children:"The Partition By clause is similar to Group By. It groups the input rows by one or more specified columns. Rows with the same value are grouped together."}),"\n",(0,r.jsx)(n.h3,{id:"order-by-clause",children:"ORDER BY clause"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Order By"})," clause is basically the same as the outer ",(0,r.jsx)(n.code,{children:"Order By"}),". It defines the order of the input rows. If ",(0,r.jsx)(n.code,{children:"Partition By"})," is specified, ",(0,r.jsx)(n.code,{children:"Order By"})," defines the order within each Partition grouping. The only difference is that ",(0,r.jsx)(n.code,{children:"Order By n"})," (n is a positive integer) in the ",(0,r.jsx)(n.code,{children:"OVER"})," clause is equivalent to no operation, whereas ",(0,r.jsx)(n.code,{children:"n"})," in the outer ",(0,r.jsx)(n.code,{children:"Order By"})," indicates sorting by the nth column."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsxs)(n.p,{children:["This example shows adding an id column to the select list with values of 1, 2, 3, etc., sorted by the ",(0,r.jsx)(n.code,{children:"date_and_time"})," column in the events table."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT row_number() OVER (ORDER BY date_and_time) AS id,\n    c1, c2, c3, c4\nFROM events;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"window-clause",children:"Window clause"}),"\n",(0,r.jsxs)(n.p,{children:["The window clause is used to specify a range of rows for operations (the preceding and following rows based on the current row). It supports the following syntaxes: AVG(), COUNT(), FIRST_VALUE(), LAST_VALUE(), and SUM(). For MAX() and MIN(), the window clause can specify the start to ",(0,r.jsx)(n.code,{children:"UNBOUNDED PRECEDING"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"ROWS BETWEEN [ { m | UNBOUNDED } PRECEDING | CURRENT ROW] [ AND [CURRENT ROW | { UNBOUNDED | n } FOLLOWING] ]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Suppose we have the following stock data, the stock symbol is JDR, and the closing price is the daily closing price."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"create table stock_ticker (\n    stock_symbol string,\n    closing_price decimal(8,2),\n    closing_date timestamp);\n\n-- ...load some data...\n\nselect *\nfrom stock_ticker\norder by stock_symbol, closing_date\n"})}),"\n",(0,r.jsx)(n.p,{children:"The raw data was shown as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+--------------+---------------+---------------------+\n| stock_symbol | closing_price | closing_date        |\n+--------------+---------------+---------------------+\n| JDR          | 12.86         | 2014-10-02 00:00:00 |\n| JDR          | 12.89         | 2014-10-03 00:00:00 |\n| JDR          | 12.94         | 2014-10-04 00:00:00 |\n| JDR          | 12.55         | 2014-10-05 00:00:00 |\n| JDR          | 14.03         | 2014-10-06 00:00:00 |\n| JDR          | 14.75         | 2014-10-07 00:00:00 |\n| JDR          | 13.98         | 2014-10-08 00:00:00 |\n+--------------+---------------+---------------------+\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This query uses the window function to generate the moving_average column whose value is the 3-day (previous day, current day, and next day) average stock price. The first day does not have the value of its previous day, and the last day does not have the value of the day after, so these two rows only calculate the average value of two days. Here ",(0,r.jsx)(n.code,{children:"Partition By"})," does not take effect, because all the data is JDR data. However, if there is other stock information, ",(0,r.jsx)(n.code,{children:"Partition By"})," will ensure that the window function is operated within each Partition."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select stock_symbol, closing_date, closing_price,\n    avg(closing_price)\n        over (partition by stock_symbol\n              order by closing_date\n              rows between 1 preceding and 1 following\n        ) as moving_average\nfrom stock_ticker;\n"})}),"\n",(0,r.jsx)(n.p,{children:"The following data is obtained:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+--------------+---------------------+---------------+----------------+\n| stock_symbol | closing_date        | closing_price | moving_average |\n+--------------+---------------------+---------------+----------------+\n| JDR          | 2014-10-02 00:00:00 | 12.86         | 12.87          |\n| JDR          | 2014-10-03 00:00:00 | 12.89         | 12.89          |\n| JDR          | 2014-10-04 00:00:00 | 12.94         | 12.79          |\n| JDR          | 2014-10-05 00:00:00 | 12.55         | 13.17          |\n| JDR          | 2014-10-06 00:00:00 | 14.03         | 13.77          |\n| JDR          | 2014-10-07 00:00:00 | 14.75         | 14.25          |\n| JDR          | 2014-10-08 00:00:00 | 13.98         | 14.36          |\n+--------------+---------------------+---------------+----------------+\n"})}),"\n",(0,r.jsx)(n.h2,{id:"function-examples",children:"Function Examples"}),"\n",(0,r.jsx)(n.p,{children:"This section describes the window functions supported in StarRocks."}),"\n",(0,r.jsx)(n.h3,{id:"avg",children:"AVG()"}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"AVG(expr) [OVER (*analytic_clause*)]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Calculate the x-average of the current row and each row before and after it."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, property,\n    avg(x)\n        over (\n            partition by property\n            order by x\n            rows between 1 preceding and 1 following\n        ) as 'moving average'\nfrom int_t\nwhere property in ('odd','even');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+----+----------+----------------+\n| x  | property | moving average |\n+----+----------+----------------+\n| 2  | even     | 3              |\n| 4  | even     | 4              |\n| 6  | even     | 6              |\n| 8  | even     | 8              |\n| 10 | even     | 9              |\n| 1  | odd      | 2              |\n| 3  | odd      | 3              |\n| 5  | odd      | 5              |\n| 7  | odd      | 7              |\n| 9  | odd      | 8              |\n+----+----------+----------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"count",children:"COUNT()"}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"COUNT(expr) [OVER (analytic_clause)]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Count the occurrence of x from the current row to the first row."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, property,\n    count(x)\n        over (\n            partition by property\n            order by x\n            rows between unbounded preceding and current row\n        ) as 'cumulative total'\nfrom int_t where property in ('odd','even');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+----+----------+------------------+\n| x  | property | cumulative count |\n+----+----------+------------------+\n| 2  | even     | 1                |\n| 4  | even     | 2                |\n| 6  | even     | 3                |\n| 8  | even     | 4                |\n| 10 | even     | 5                |\n| 1  | odd      | 1                |\n| 3  | odd      | 2                |\n| 5  | odd      | 3                |\n| 7  | odd      | 4                |\n| 9  | odd      | 5                |\n+----+----------+------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cume_dist",children:"CUME_DIST()"}),"\n",(0,r.jsx)(n.p,{children:"The CUME_DIST() function calculates the cumulative distribution of a value within a partition, indicating its relative position as a percentage of values less than or equal to the value in the current row. With a range of 0 to 1, it's useful for percentile calculations and data distribution analysis."}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"CUME_DIST() OVER (partition_by_clause order_by_clause)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"This function should be used with ORDER BY to sort partition rows into the desired order. Without ORDER BY, all rows are peers and have value N/N = 1, where N is the partition size."})}),"\n",(0,r.jsx)(n.p,{children:"CUME_DIST() contains NULL values and treats them as the lowest values."}),"\n",(0,r.jsx)(n.p,{children:"The following example shows the cumulative distribution of column y within each group of column x."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT x, y,\n    CUME_DIST()\n        OVER (\n            PARTITION BY x\n            ORDER BY y\n        ) AS `cume_dist`\nFROM int_t;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+---+--------------------+\n| x | y | cume_dist          |\n+---+---+--------------------+\n| 1 | 1 | 0.3333333333333333 |\n| 1 | 2 |                  1 |\n| 1 | 2 |                  1 |\n| 2 | 1 | 0.3333333333333333 |\n| 2 | 2 | 0.6666666666666667 |\n| 2 | 3 |                  1 |\n| 3 | 1 | 0.6666666666666667 |\n| 3 | 1 | 0.6666666666666667 |\n| 3 | 2 |                  1 |\n+---+---+--------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dense_rank",children:"DENSE_RANK()"}),"\n",(0,r.jsxs)(n.p,{children:["The DENSE_RANK() function is used to represent rankings. Unlike RANK(), DENSE_RANK()",(0,r.jsx)(n.strong,{children:"does not have vacant"})," numbers. For example, if there are two tied 1s, the third number of DENSE_RANK() is still 2, whereas the third number of RANK() is 3."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"DENSE_RANK() OVER(partition_by_clause order_by_clause)\n"})}),"\n",(0,r.jsx)(n.p,{children:"The following example shows the ranking of column x according to the property column grouping."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, y,\n    dense_rank()\n        over (\n            partition by x\n            order by y\n        ) as `rank`\nfrom int_t;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+---+------+\n| x | y | rank |\n+---+---+------+\n| 1 | 1 | 1    |\n| 1 | 2 | 2    |\n| 1 | 2 | 2    |\n| 2 | 1 | 1    |\n| 2 | 2 | 2    |\n| 2 | 3 | 3    |\n| 3 | 1 | 1    |\n| 3 | 1 | 1    |\n| 3 | 2 | 2    |\n+---+---+------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"ntile",children:"NTILE()"}),"\n",(0,r.jsxs)(n.p,{children:["NTILE() function divides the sorted rows in a partition by the specified number of ",(0,r.jsx)(n.code,{children:"num_buckets"})," as equally as possible, stores the divided rows in the respective buckets, starting from 1 ",(0,r.jsx)(n.code,{children:"[1, 2, ..., num_buckets]"}),", and returns the bucket number that each row is in."]}),"\n",(0,r.jsx)(n.p,{children:"About the size of the bucket:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If the row counts can be divided by the specified number of ",(0,r.jsx)(n.code,{children:"num_buckets"})," exactly, all the buckets will be of the same size."]}),"\n",(0,r.jsxs)(n.li,{children:["If the row counts cannot be divided by the specified number of ",(0,r.jsx)(n.code,{children:"num_buckets"})," exactly, there will be buckets of two different sizes. The difference between sizes is 1. The buckets with more rows will be listed ahead of the one with fewer rows."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"NTILE (num_buckets) OVER (partition_by_clause order_by_clause)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"num_buckets"}),": Number of the buckets to be created. The value must be a constant positive integer whose maximum is ",(0,r.jsx)(n.code,{children:"2^63 - 1"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Window clause is not allowed in NTILE() function"}),"\n",(0,r.jsx)(n.p,{children:"NTILE() function returns BIGINT type of data."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"The following example divides all rows in the partition into 2 buckets."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"select id, x, y,\n    ntile(2)\n        over (\n            partition by x\n            order by y\n        ) as bucket_id\nfrom t1;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+------+------+------+-----------+\n| id   | x    | y    | bucket_id |\n+------+------+------+-----------+\n|    1 |    1 |   11 |         1 |\n|    2 |    1 |   11 |         1 |\n|    3 |    1 |   22 |         1 |\n|    4 |    1 |   33 |         2 |\n|    5 |    1 |   44 |         2 |\n|    6 |    1 |   55 |         2 |\n|    7 |    2 |   66 |         1 |\n|    8 |    2 |   77 |         1 |\n|    9 |    2 |   88 |         2 |\n|   10 |    3 |   99 |         1 |\n+------+------+------+-----------+\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As the above example shown, when ",(0,r.jsx)(n.code,{children:"num_buckets"})," is ",(0,r.jsx)(n.code,{children:"2"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rows of No.1 to No.6 were classified into the first partition; rows of No.1 to No.3 were stored in the first bucket, and rows of No.4 to No.6 were stored in the second one."}),"\n",(0,r.jsx)(n.li,{children:"Rows of No.7 to No.9 were classified into the second partition; rows of No.7 and No.8 were stored in the first bucket, and row No.9 was stored in the second one."}),"\n",(0,r.jsx)(n.li,{children:"Row No.10 was classified into the third partition and stored in the first bucket."}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"first_value",children:"FIRST_VALUE()"}),"\n",(0,r.jsxs)(n.p,{children:["FIRST_VALUE() returns the ",(0,r.jsx)(n.strong,{children:"first"})," value of the window range."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"FIRST_VALUE(expr [IGNORE NULLS]) OVER(partition_by_clause order_by_clause [window_clause])\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"IGNORE NULLS"})," is supported from v2.5.0. It is used to determine whether NULL values of ",(0,r.jsx)(n.code,{children:"expr"})," are eliminated from the calculation. By default, NULL values are included, which means NULL is returned if the first value in the filtered result is NULL. If you specify IGNORE NULLS, the first non-null value in the filtered result is returned. If all the values are NULL, NULL is returned even if you specify IGNORE NULLS."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"We have the following data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:" select name, country, greeting\n from mail_merge;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---------+---------+--------------+\n| name    | country | greeting     |\n+---------+---------+--------------+\n| Pete    | USA     | Hello        |\n| John    | USA     | Hi           |\n| Boris   | Germany | Guten tag    |\n| Michael | Germany | Guten morgen |\n| Bjorn   | Sweden  | Hej          |\n| Mats    | Sweden  | Tja          |\n+---------+---------+--------------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use FIRST_VALUE() to return the first greeting value in each grouping, based on the country grouping."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select country, name,\n    first_value(greeting)\n        over (\n            partition by country\n            order by name, greeting\n        ) as greeting\nfrom mail_merge;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---------+---------+-----------+\n| country | name    | greeting  |\n+---------+---------+-----------+\n| Germany | Boris   | Guten tag |\n| Germany | Michael | Guten tag |\n| Sweden  | Bjorn   | Hej       |\n| Sweden  | Mats    | Hej       |\n| USA     | John    | Hi        |\n| USA     | Pete    | Hi        |\n+---------+---------+-----------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lag",children:"LAG()"}),"\n",(0,r.jsxs)(n.p,{children:["Returns the value of the row that lags the current row by ",(0,r.jsx)(n.code,{children:"offset"})," rows. This function is often used to compare values between rows and filter data."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"LAG()"})," can be used to query data of the following types:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Numeric: TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, DECIMAL"}),"\n",(0,r.jsx)(n.li,{children:"String: CHAR, VARCHAR"}),"\n",(0,r.jsx)(n.li,{children:"Date: DATE, DATETIME"}),"\n",(0,r.jsx)(n.li,{children:"BITMAP and HLL are supported from StarRocks v2.5."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"LAG(expr [IGNORE NULLS] [, offset[, default]])\nOVER([<partition_by_clause>] [<order_by_clause>])\n"})}),"\n",(0,r.jsx)(n.p,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"expr"}),": the field you want to compute."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"offset"}),": the offset. It must be a ",(0,r.jsx)(n.strong,{children:"positive integer"}),". If this parameter is not specified, 1 is the default."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default"}),": the default value returned if no matching row is found. If this parameter is not specified, NULL is the default. ",(0,r.jsx)(n.code,{children:"default"})," supports any expression whose type is compatible with ",(0,r.jsx)(n.code,{children:"expr"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"IGNORE NULLS"})," is supported from v3.0. It is used to determine whether NULL values of ",(0,r.jsx)(n.code,{children:"expr"})," are included in the result. By default, NULL values are included when ",(0,r.jsx)(n.code,{children:"offset"})," rows are counted, which means NULL is returned if the value of the destination row is NULL. See Example 1. If you specify IGNORE NULLS, NULL values are ignored when ",(0,r.jsx)(n.code,{children:"offset"})," rows are counted and the system continues to search for ",(0,r.jsx)(n.code,{children:"offset"})," non-null values. If ",(0,r.jsx)(n.code,{children:"offset"})," non-null values cannot be found, NULL or ",(0,r.jsx)(n.code,{children:"default"})," (if specified) is returned. See Example 2."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example 1: IGNORE NULLS is not specified"}),"\n",(0,r.jsx)(n.p,{children:"Create a table and insert values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"CREATE TABLE test_tbl (col_1 INT, col_2 INT)\nDISTRIBUTED BY HASH(col_1);\n\nINSERT INTO test_tbl VALUES \n    (1, NULL),\n    (2, 4),\n    (3, NULL),\n    (4, 2),\n    (5, NULL),\n    (6, 7),\n    (7, 6),\n    (8, 5),\n    (9, NULL),\n    (10, NULL);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Query data from this table, where ",(0,r.jsx)(n.code,{children:"offset"})," is 2, which means traversing the previous two rows; ",(0,r.jsx)(n.code,{children:"default"})," is 0, which means 0 is returned if no matching rows are found."]}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"SELECT col_1, col_2, LAG(col_2,2,0) OVER (ORDER BY col_1) \nFROM test_tbl ORDER BY col_1;\n+-------+-------+---------------------------------------------+\n| col_1 | col_2 | lag(col_2, 2, 0) OVER (ORDER BY col_1 ASC ) |\n+-------+-------+---------------------------------------------+\n|     1 |  NULL |                                           0 |\n|     2 |     4 |                                           0 |\n|     3 |  NULL |                                        NULL |\n|     4 |     2 |                                           4 |\n|     5 |  NULL |                                        NULL |\n|     6 |     7 |                                           2 |\n|     7 |     6 |                                        NULL |\n|     8 |     5 |                                           7 |\n|     9 |  NULL |                                           6 |\n|    10 |  NULL |                                           5 |\n+-------+-------+---------------------------------------------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"For the first two rows, no previous two rows exist and the default value 0 is returned."}),"\n",(0,r.jsx)(n.p,{children:"For NULL in row 3, the value two rows backward is NULL and NULL is returned because NULL values are allowed."}),"\n",(0,r.jsx)(n.p,{children:"Example 2: IGNORE NULLS is specified"}),"\n",(0,r.jsx)(n.p,{children:"Use the preceding table and parameter settings."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT col_1, col_2, LAG(col_2 IGNORE NULLS,2,0) OVER (ORDER BY col_1) \nFROM test_tbl ORDER BY col_1;\n+-------+-------+---------------------------------------------+\n| col_1 | col_2 | lag(col_2, 2, 0) OVER (ORDER BY col_1 ASC ) |\n+-------+-------+---------------------------------------------+\n|     1 |  NULL |                                           0 |\n|     2 |     4 |                                           0 |\n|     3 |  NULL |                                           0 |\n|     4 |     2 |                                           0 |\n|     5 |  NULL |                                           4 |\n|     6 |     7 |                                           4 |\n|     7 |     6 |                                           2 |\n|     8 |     5 |                                           7 |\n|     9 |  NULL |                                           6 |\n|    10 |  NULL |                                           6 |\n+-------+-------+---------------------------------------------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"For rows 1 to 4, the system cannot find two non-NULL values for each of them in the previous rows and the default value 0 is returned."}),"\n",(0,r.jsx)(n.p,{children:"For value 6 in row 7, the value two rows backward is NULL and NULL is ignored because IGNORE NULLS is specified. The system continues to search for non-null values and 2 in row 4 is returned."}),"\n",(0,r.jsx)(n.h3,{id:"last_value",children:"LAST_VALUE()"}),"\n",(0,r.jsxs)(n.p,{children:["LAST_VALUE() returns the ",(0,r.jsx)(n.strong,{children:"last"})," value of the window range. It is the opposite of FIRST_VALUE()."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"LAST_VALUE(expr [IGNORE NULLS]) OVER(partition_by_clause order_by_clause [window_clause])\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"IGNORE NULLS"})," is supported from v2.5.0. It is used to determine whether NULL values of ",(0,r.jsx)(n.code,{children:"expr"})," are eliminated from the calculation. By default, NULL values are included, which means NULL is returned if the last value in the filtered result is NULL. If you specify IGNORE NULLS, the last non-null value in the filtered result is returned. If all the values are NULL, NULL is returned even if you specify IGNORE NULLS."]}),"\n",(0,r.jsx)(n.p,{children:"Use the data from the example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select country, name,\n    last_value(greeting)\n        over (\n            partition by country\n            order by name, greeting\n        ) as greeting\nfrom mail_merge;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---------+---------+--------------+\n| country | name    | greeting     |\n+---------+---------+--------------+\n| Germany | Boris   | Guten morgen |\n| Germany | Michael | Guten morgen |\n| Sweden  | Bjorn   | Tja          |\n| Sweden  | Mats    | Tja          |\n| USA     | John    | Hello        |\n| USA     | Pete    | Hello        |\n+---------+---------+--------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lead",children:"LEAD()"}),"\n",(0,r.jsxs)(n.p,{children:["Returns the value of the row that leads the current row by ",(0,r.jsx)(n.code,{children:"offset"})," rows. This function is often used to compare values between rows and filter data."]}),"\n",(0,r.jsxs)(n.p,{children:["Data types that can be queried by ",(0,r.jsx)(n.code,{children:"lead()"})," are the same as those supported by ",(0,r.jsx)(n.a,{href:"#lag",children:"lag()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"LEAD(expr [IGNORE NULLS] [, offset[, default]])\nOVER([<partition_by_clause>] [<order_by_clause>])\n"})}),"\n",(0,r.jsx)(n.p,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"expr"}),": the field you want to compute."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"offset"}),": the offset. It must be a positive integer. If this parameter is not specified, 1 is the default."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default"}),": the default value returned if no matching row is found. If this parameter is not specified, NULL is the default. ",(0,r.jsx)(n.code,{children:"default"})," supports any expression whose type is compatible with ",(0,r.jsx)(n.code,{children:"expr"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"IGNORE NULLS"})," is supported from v3.0. It is used to determine whether NULL values of ",(0,r.jsx)(n.code,{children:"expr"})," are included in the result. By default, NULL values are included when ",(0,r.jsx)(n.code,{children:"offset"})," rows are counted, which means NULL is returned if the value of the destination row is NULL. See Example 1. If you specify IGNORE NULLS, NULL values are ignored when ",(0,r.jsx)(n.code,{children:"offset"})," rows are counted and the system continues to search for ",(0,r.jsx)(n.code,{children:"offset"})," non-null values. If ",(0,r.jsx)(n.code,{children:"offset"})," non-null values cannot be found, NULL or ",(0,r.jsx)(n.code,{children:"default"})," (if specified) is returned. See Example 2."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example 1: IGNORE NULLS is not specified"}),"\n",(0,r.jsx)(n.p,{children:"Create a table and insert values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"CREATE TABLE test_tbl (col_1 INT, col_2 INT)\nDISTRIBUTED BY HASH(col_1);\n\nINSERT INTO test_tbl VALUES \n    (1, NULL),\n    (2, 4),\n    (3, NULL),\n    (4, 2),\n    (5, NULL),\n    (6, 7),\n    (7, 6),\n    (8, 5),\n    (9, NULL),\n    (10, NULL);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Query data from this table, where ",(0,r.jsx)(n.code,{children:"offset"})," is 2, which means traversing the subsequent two rows; ",(0,r.jsx)(n.code,{children:"default"})," is 0, which means 0 is returned if no matching rows are found."]}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"SELECT col_1, col_2, LEAD(col_2,2,0) OVER (ORDER BY col_1) \nFROM test_tbl ORDER BY col_1;\n+-------+-------+----------------------------------------------+\n| col_1 | col_2 | lead(col_2, 2, 0) OVER (ORDER BY col_1 ASC ) |\n+-------+-------+----------------------------------------------+\n|     1 |  NULL |                                         NULL |\n|     2 |     4 |                                            2 |\n|     3 |  NULL |                                         NULL |\n|     4 |     2 |                                            7 |\n|     5 |  NULL |                                            6 |\n|     6 |     7 |                                            5 |\n|     7 |     6 |                                         NULL |\n|     8 |     5 |                                         NULL |\n|     9 |  NULL |                                            0 |\n|    10 |  NULL |                                            0 |\n+-------+-------+----------------------------------------------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"For the first row, the value two rows forward is NULL and NULL is returned because NULL values are allowed."}),"\n",(0,r.jsx)(n.p,{children:"For the last two rows, no subsequent two rows exist and the default value 0 is returned."}),"\n",(0,r.jsx)(n.p,{children:"Example 2: IGNORE NULLS is specified"}),"\n",(0,r.jsx)(n.p,{children:"Use the preceding table and parameter settings."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT col_1, col_2, LEAD(col_2 IGNORE NULLS,2,0) OVER (ORDER BY col_1) \nFROM test_tbl ORDER BY col_1;\n+-------+-------+----------------------------------------------+\n| col_1 | col_2 | lead(col_2, 2, 0) OVER (ORDER BY col_1 ASC ) |\n+-------+-------+----------------------------------------------+\n|     1 |  NULL |                                            2 |\n|     2 |     4 |                                            7 |\n|     3 |  NULL |                                            7 |\n|     4 |     2 |                                            6 |\n|     5 |  NULL |                                            6 |\n|     6 |     7 |                                            5 |\n|     7 |     6 |                                            0 |\n|     8 |     5 |                                            0 |\n|     9 |  NULL |                                            0 |\n|    10 |  NULL |                                            0 |\n+-------+-------+----------------------------------------------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"For rows 7 to 10, the system cannot find two non-null values in the subsequent rows and the default value 0 is returned."}),"\n",(0,r.jsx)(n.p,{children:"For the first row, the value two rows forward is NULL and NULL is ignored because IGNORE NULLS is specified. The system continues to search for the second non-null value and 2 in row 4 is returned."}),"\n",(0,r.jsx)(n.h3,{id:"max",children:"MAX()"}),"\n",(0,r.jsx)(n.p,{children:"Returns the maximum value of the specified rows in the current window."}),"\n",(0,r.jsx)(n.p,{children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"MAX(expr) [OVER (analytic_clause)]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Calculate the maximum value of rows from the first row to the row after the current row."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, property,\n    max(x)\n        over (\n            order by property, x\n            rows between unbounded preceding and 1 following\n        ) as 'local maximum'\nfrom int_t\nwhere property in ('prime','square');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+----------+---------------+\n| x | property | local maximum |\n+---+----------+---------------+\n| 2 | prime    | 3             |\n| 3 | prime    | 5             |\n| 5 | prime    | 7             |\n| 7 | prime    | 7             |\n| 1 | square   | 7             |\n| 4 | square   | 9             |\n| 9 | square   | 9             |\n+---+----------+---------------+\n"})}),"\n",(0,r.jsxs)(n.p,{children:["From StarRocks 2.4 onwards, you can specify the row range as ",(0,r.jsx)(n.code,{children:"rows between n preceding and n following"}),", which means you can capture ",(0,r.jsx)(n.code,{children:"n"})," rows before the current row and ",(0,r.jsx)(n.code,{children:"n"})," rows after the current row."]}),"\n",(0,r.jsx)(n.p,{children:"Example statement:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"select x, property,\n    max(x)\n        over (\n            order by property, x\n            rows between 3 preceding and 2 following) as 'local maximum'\nfrom int_t\nwhere property in ('prime','square');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"min",children:"MIN()"}),"\n",(0,r.jsx)(n.p,{children:"Returns the minimum value of the specified rows in the current window."}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"MIN(expr) [OVER (analytic_clause)]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Calculate the minimum value of rows from the first row to the row after the current row."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, property,\n    min(x)\n        over (\n            order by property, x desc\n            rows between unbounded preceding and 1 following\n        ) as 'local minimum'\nfrom int_t\nwhere property in ('prime','square');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+----------+---------------+\n| x | property | local minimum |\n+---+----------+---------------+\n| 7 | prime    | 5             |\n| 5 | prime    | 3             |\n| 3 | prime    | 2             |\n| 2 | prime    | 2             |\n| 9 | square   | 2             |\n| 4 | square   | 1             |\n| 1 | square   | 1             |\n+---+----------+---------------+\n"})}),"\n",(0,r.jsxs)(n.p,{children:["From StarRocks 2.4 onwards, you can specify the row range as ",(0,r.jsx)(n.code,{children:"rows between n preceding and n following"}),", which means you can capture ",(0,r.jsx)(n.code,{children:"n"})," rows before the current row and ",(0,r.jsx)(n.code,{children:"n"})," rows after the current row."]}),"\n",(0,r.jsx)(n.p,{children:"Example statement:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"select x, property,\n    min(x)\n    over (\n          order by property, x desc\n          rows between 3 preceding and 2 following) as 'local minimum'\nfrom int_t\nwhere property in ('prime','square');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"percent_rank",children:"PERCENT_RANK()"}),"\n",(0,r.jsx)(n.p,{children:"The PERCENT_RANK() function calculates the relative rank of a row within a result set as a percentage. It returns the percentage of partition values less than the value in the current row, excluding the highest value. The return values range from 0 to 1. This function is useful for percentile calculations and analyzing data distribution."}),"\n",(0,r.jsx)(n.p,{children:"The PERCENT_RANK() function is calculated using the following formula, where rank represents the row rank and rows represents the number of partition rows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"(rank - 1) / (rows - 1)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"PERCENT_RANK() OVER (partition_by_clause order_by_clause)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"This function should be used with ORDER BY to sort partition rows into the desired order. Without ORDER BY, all rows are peers and have value (1 - 1)/(N - 1) = 0, where N is the partition size."})}),"\n",(0,r.jsx)(n.p,{children:"The following example shows the relative rank of column y within each group of column x."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT x, y,\n    PERCENT_RANK()\n        OVER (\n            PARTITION BY x\n            ORDER BY y\n        ) AS `percent_rank`\nFROM int_t;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+---+--------------+\n| x | y | percent_rank |\n+---+---+--------------+\n| 1 | 1 |            0 |\n| 1 | 2 |          0.5 |\n| 1 | 2 |          0.5 |\n| 2 | 1 |            0 |\n| 2 | 2 |          0.5 |\n| 2 | 3 |            1 |\n| 3 | 1 |            0 |\n| 3 | 1 |            0 |\n| 3 | 2 |            1 |\n+---+---+--------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rank",children:"RANK()"}),"\n",(0,r.jsxs)(n.p,{children:["The RANK() function is used to represent rankings. Unlike DENSE_RANK(), RANK() will ",(0,r.jsx)(n.strong,{children:"appear as a vacant"})," number. For example, if two tied 1s appear, the third number of RANK() will be 3 instead of 2."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"RANK() OVER(partition_by_clause order_by_clause)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.p,{children:"Ranking according to column x:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, y, rank() over(partition by x order by y) as `rank`\nfrom int_t;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+---+------+\n| x | y | rank |\n+---+---+------+\n| 1 | 1 | 1    |\n| 1 | 2 | 2    |\n| 1 | 2 | 2    |\n| 2 | 1 | 1    |\n| 2 | 2 | 2    |\n| 2 | 3 | 3    |\n| 3 | 1 | 1    |\n| 3 | 1 | 1    |\n| 3 | 2 | 3    |\n+---+---+------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"row_number",children:"ROW_NUMBER()"}),"\n",(0,r.jsxs)(n.p,{children:["Returns a continuously increasing integer starting from 1 for each row of a Partition. Unlike RANK() and DENSE_RANK(), the value returned by ROW_NUMBER() ",(0,r.jsx)(n.strong,{children:"does not repeat or have gaps"})," and is ",(0,r.jsx)(n.strong,{children:"continuously incremented"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"ROW_NUMBER() OVER(partition_by_clause order_by_clause)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, y, row_number() over(partition by x order by y) as `rank`\nfrom int_t;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+---+---+------+\n| x | y | rank |\n+---+---+------+\n| 1 | 1 | 1    |\n| 1 | 2 | 2    |\n| 1 | 2 | 3    |\n| 2 | 1 | 1    |\n| 2 | 2 | 2    |\n| 2 | 3 | 3    |\n| 3 | 1 | 1    |\n| 3 | 1 | 2    |\n| 3 | 2 | 3    |\n+---+---+------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"qualify",children:"QUALIFY()"}),"\n",(0,r.jsx)(n.p,{children:"The QUALIFY clause filters the results of window functions. In a SELECT statement, you can use the QUALIFY clause to apply conditions to a column to filter results. QUALIFY is analogous to the HAVING clause in aggregate functions. This function is supported from v2.5."}),"\n",(0,r.jsx)(n.p,{children:"QUALIFY simplifies the writing of SELECT statements."}),"\n",(0,r.jsx)(n.p,{children:"Before QUALIFY is used, a SELECT statement may go like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT *\nFROM (SELECT DATE,\n             PROVINCE_CODE,\n             TOTAL_SCORE,\n             ROW_NUMBER() OVER(PARTITION BY PROVINCE_CODE ORDER BY TOTAL_SCORE) AS SCORE_ROWNUMBER\n      FROM example_table) T1\nWHERE T1.SCORE_ROWNUMBER = 1;\n"})}),"\n",(0,r.jsx)(n.p,{children:"After QUALIFY is used, the statement is shortened to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT DATE, PROVINCE_CODE, TOTAL_SCORE\nFROM example_table \nQUALIFY ROW_NUMBER() OVER(PARTITION BY PROVINCE_CODE ORDER BY TOTAL_SCORE) = 1;\n"})}),"\n",(0,r.jsx)(n.p,{children:"QUALIFY supports only the following three window functions: ROW_NUMBER(), RANK(), and DENSE_RANK()."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT <column_list>\nFROM <data_source>\n[GROUP BY ...]\n[HAVING ...]\nQUALIFY <window_function>\n[ ... ]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<column_list>"}),": columns from which you want to obtain data."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<data_source>"}),": The data source is generally a table."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<window_function>"}),": The ",(0,r.jsx)(n.code,{children:"QUALIFY"})," clause can only be followed by a window function, including ROW_NUMBER(), RANK(), and DENSE_RANK()."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"-- Create a table.\nCREATE TABLE sales_record (\n   city_id INT,\n   item STRING,\n   sales INT\n) DISTRIBUTED BY HASH(`city_id`);\n\n-- Insert data into the table.\ninsert into sales_record values\n(1,'fruit',95),\n(2,'drinks',70),\n(3,'fruit',87),\n(4,'drinks',98);\n\n-- Query data from the table.\nselect * from sales_record order by city_id;\n+---------+--------+-------+\n| city_id | item   | sales |\n+---------+--------+-------+\n|       1 | fruit  |    95 |\n|       2 | drinks |    70 |\n|       3 | fruit  |    87 |\n|       4 | drinks |    98 |\n+---------+--------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example 1: Obtain records whose row number is greater than 1 from the table."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT city_id, item, sales\nFROM sales_record\nQUALIFY row_number() OVER (ORDER BY city_id) > 1;\n+---------+--------+-------+\n| city_id | item   | sales |\n+---------+--------+-------+\n|       2 | drinks |    70 |\n|       3 | fruit  |    87 |\n|       4 | drinks |    98 |\n+---------+--------+-------+\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Example 2: Obtain records whose row number is 1 from each partition of the table. The table is divided into two partitions by ",(0,r.jsx)(n.code,{children:"item"})," and the first row in each partition is returned."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT city_id, item, sales\nFROM sales_record \nQUALIFY ROW_NUMBER() OVER (PARTITION BY item ORDER BY city_id) = 1\nORDER BY city_id;\n+---------+--------+-------+\n| city_id | item   | sales |\n+---------+--------+-------+\n|       1 | fruit  |    95 |\n|       2 | drinks |    70 |\n+---------+--------+-------+\n2 rows in set (0.01 sec)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Example 3: Obtain records whose sales rank No.1 from each partition of the table. The table is divided into two partitions by ",(0,r.jsx)(n.code,{children:"item"})," and the row with the highest sales in each partition is returned."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SELECT city_id, item, sales\nFROM sales_record\nQUALIFY RANK() OVER (PARTITION BY item ORDER BY sales DESC) = 1\nORDER BY city_id;\n+---------+--------+-------+\n| city_id | item   | sales |\n+---------+--------+-------+\n|       1 | fruit  |    95 |\n|       4 | drinks |    98 |\n+---------+--------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Usage notes:"})}),"\n",(0,r.jsx)(n.p,{children:"The execution order of clauses in a query with QUALIFY is evaluated in the following order:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"From"}),"\n",(0,r.jsx)(n.li,{children:"Where"}),"\n",(0,r.jsx)(n.li,{children:"Group by"}),"\n",(0,r.jsx)(n.li,{children:"Having"}),"\n",(0,r.jsx)(n.li,{children:"Window"}),"\n",(0,r.jsx)(n.li,{children:"QUALIFY"}),"\n",(0,r.jsx)(n.li,{children:"Distinct"}),"\n",(0,r.jsx)(n.li,{children:"Order by"}),"\n",(0,r.jsx)(n.li,{children:"Limit"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sum",children:"SUM()"}),"\n",(0,r.jsx)(n.p,{children:"Syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"SUM(expr) [OVER (analytic_clause)]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsxs)(n.p,{children:["Group by property and calculate the sum of the ",(0,r.jsx)(n.strong,{children:"current, preceding, and following rows"})," within the group."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"select x, property,\n    sum(x)\n        over (\n            partition by property\n            order by x\n            rows between 1 preceding and 1 following\n        ) as 'moving total'\nfrom int_t where property in ('odd','even');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"+----+----------+--------------+\n| x  | property | moving total |\n+----+----------+--------------+\n| 2  | even     | 6            |\n| 4  | even     | 12           |\n| 6  | even     | 18           |\n| 8  | even     | 24           |\n| 10 | even     | 18           |\n| 1  | odd      | 4            |\n| 3  | odd      | 9            |\n| 5  | odd      | 15           |\n| 7  | odd      | 21           |\n+----+----------+--------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"variance-var_pop-variance_pop",children:"VARIANCE, VAR_POP, VARIANCE_POP"}),"\n",(0,r.jsx)(n.p,{children:"Returns the population variance of an expression. VAR_POP and VARIANCE_POP are aliases of VARIANCE. These functions can be used as window functions since v2.5.10."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"VARIANCE(expr) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"VARIANCE() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the VARIANCE() function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select variance(k) over (partition by no) FROM agg;\n+-------------------------------------+\n| variance(k) OVER (PARTITION BY no ) |\n+-------------------------------------+\n|                                   0 |\n|                             54.6875 |\n|                             54.6875 |\n|                             54.6875 |\n|                             54.6875 |\n+-------------------------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"var_samp-variance_samp",children:"VAR_SAMP, VARIANCE_SAMP"}),"\n",(0,r.jsx)(n.p,{children:"Returns the sample variance of an expression. These functions can be used as window functions since v2.5.10."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"VAR_SAMP(expr) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"VAR_SAMP() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the VAR_SAMP() window function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select VAR_SAMP(k) over (partition by no) FROM agg;\n+-------------------------------------+\n| var_samp(k) OVER (PARTITION BY no ) |\n+-------------------------------------+\n|                                   0 |\n|                   72.91666666666667 |\n|                   72.91666666666667 |\n|                   72.91666666666667 |\n|                   72.91666666666667 |\n+-------------------------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"std-stddev-stddev_pop",children:"STD, STDDEV, STDDEV_POP"}),"\n",(0,r.jsx)(n.p,{children:"Returns the standard deviation of an expression. These functions can be used as window functions since v2.5.10."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"STD(expr) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"STD() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the STD() window function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select STD(k) over (partition by no) FROM agg;\n+--------------------------------+\n| std(k) OVER (PARTITION BY no ) |\n+--------------------------------+\n|                              0 |\n|               7.39509972887452 |\n|               7.39509972887452 |\n|               7.39509972887452 |\n|               7.39509972887452 |\n+--------------------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"stddev_samp",children:"STDDEV_SAMP"}),"\n",(0,r.jsx)(n.p,{children:"Returns the sample standard deviation of an expression. This function can be used as a window function since v2.5.10."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"STDDEV_SAMP(expr) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"STDDEV_SAMP() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the STDDEV_SAMP() window function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select STDDEV_SAMP(k) over (partition by no) FROM agg;\n+----------------------------------------+\n| stddev_samp(k) OVER (PARTITION BY no ) |\n+----------------------------------------+\n|                                      0 |\n|                      8.539125638299666 |\n|                      8.539125638299666 |\n|                      8.539125638299666 |\n|                      8.539125638299666 |\n+----------------------------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"covar_samp",children:"COVAR_SAMP"}),"\n",(0,r.jsx)(n.p,{children:"Returns the sample covariance of two expressions. This function is supported from v2.5.10. It is also an aggregate function."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"COVAR_SAMP(expr1,expr2) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"COVAR_SAMP() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the COVAR_SAMP() window function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select COVAR_SAMP(k, v) over (partition by no) FROM agg;\n+------------------------------------------+\n| covar_samp(k, v) OVER (PARTITION BY no ) |\n+------------------------------------------+\n|                                     NULL |\n|                       119.99999999999999 |\n|                       119.99999999999999 |\n|                       119.99999999999999 |\n|                       119.99999999999999 |\n+------------------------------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"covar_pop",children:"COVAR_POP"}),"\n",(0,r.jsx)(n.p,{children:"Returns the population covariance of two expressions. This function is supported from v2.5.10. It is also an aggregate function."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"COVAR_POP(expr1, expr2) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"COVAR_POP() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the COVAR_POP() window function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select COVAR_POP(k, v) over (partition by no) FROM agg;\n+-----------------------------------------+\n| covar_pop(k, v) OVER (PARTITION BY no ) |\n+-----------------------------------------+\n|                                    NULL |\n|                       79.99999999999999 |\n|                       79.99999999999999 |\n|                       79.99999999999999 |\n|                       79.99999999999999 |\n+-----------------------------------------+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"corr",children:"CORR"}),"\n",(0,r.jsx)(n.p,{children:"Returns the Pearson correlation coefficient between two expressions. This function is supported from v2.5.10. It is also an aggregate function."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CORR(expr1, expr2) [OVER (partition_by_clause)]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,r.jsx)(n.p,{children:"CORR() only supports PARTITION BY. It does not support ORDER BY or Window clauses."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"expr"})," is a table column, it must evaluate to TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, or DECIMAL."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose table ",(0,r.jsx)(n.code,{children:"agg"})," has the following data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select * from agg;\n+------+-------+-------+\n| no   | k     | v     |\n+------+-------+-------+\n|    1 | 10.00 |  NULL |\n|    2 | 10.00 | 11.00 |\n|    2 | 20.00 | 22.00 |\n|    2 | 25.00 |  NULL |\n|    2 | 30.00 | 35.00 |\n+------+-------+-------+\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use the CORR() window function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"mysql> select CORR(k, v) over (partition by no) FROM agg;\n+------------------------------------+\n| corr(k, v) OVER (PARTITION BY no ) |\n+------------------------------------+\n|                               NULL |\n|                 0.9988445981121532 |\n|                 0.9988445981121532 |\n|                 0.9988445981121532 |\n|                 0.9988445981121532 |\n+------------------------------------+\n"})})]})}const h=function(e={}){const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(d,e)})):d(e)}},11151:(e,n,s)=>{s.d(n,{Zo:()=>a,ah:()=>l});var r=s(67294);const i=r.createContext({});function l(e){const n=r.useContext(i);return r.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const t={};function a({components:e,children:n,disableParentContext:s}){let a;return a=s?"function"==typeof e?e({}):e||t:l(e),r.createElement(i.Provider,{value:a},n)}}}]);