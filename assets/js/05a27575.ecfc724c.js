"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[22091],{5805:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>o});var t=n(85893),a=n(11151);const s={displayed_sidebar:"English"},l="Materialized View",r={id:"table_design/Materialized_view",title:"Materialized View",description:"Terminology",source:"@site/versioned_docs/version-2.2/table_design/Materialized_view.md",sourceDirName:"table_design",slug:"/table_design/Materialized_view",permalink:"/docs/2.2/table_design/Materialized_view",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/table_design/Materialized_view.md",tags:[],version:"2.2",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"Data models",permalink:"/docs/2.2/table_design/Data_model"},next:{title:"Sort keys and prefix indexes",permalink:"/docs/2.2/table_design/Sort_key"}},d={},o=[{value:"Terminology",id:"terminology",level:2},{value:"Use Scenarios",id:"use-scenarios",level:2},{value:"How to use",id:"how-to-use",level:2},{value:"<strong>Build a materialized view</strong>",id:"build-a-materialized-view",level:3},{value:"<strong>DROP MATERIALIZED VIEW</strong>",id:"drop-materialized-view",level:3},{value:"<strong>View materialized views</strong>",id:"view-materialized-views",level:3},{value:"<strong>Importing Data</strong>",id:"importing-data",level:3},{value:"Notes",id:"notes",level:2},{value:"<strong>Materialized view function support</strong>",id:"materialized-view-function-support",level:3},{value:"<strong>Intelligent routing of materialized views</strong>",id:"intelligent-routing-of-materialized-views",level:3},{value:"<strong>Other restrictions</strong>",id:"other-restrictions",level:3}];function c(e){const i=Object.assign({h1:"h1",h2:"h2",ol:"ol",li:"li",code:"code",p:"p",ul:"ul",h3:"h3",strong:"strong",pre:"pre"},(0,a.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"materialized-view",children:"Materialized View"}),"\n",(0,t.jsx)(i.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Duplicate model: The data model stores detailed data in StarRocks. The model can be specified during table build, and the data in the metric columns will not be aggregated."}),"\n",(0,t.jsxs)(i.li,{children:["Base table: The table created by ",(0,t.jsx)(i.code,{children:"CREATE TABLE"})," in StarRocks."]}),"\n",(0,t.jsx)(i.li,{children:"Materialized Views table: Pre-calculated data set that contains results of a query. Abbreviated as MV."}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"use-scenarios",children:"Use Scenarios"}),"\n",(0,t.jsx)(i.p,{children:"In a practical business scenario, there are usually two coexisting use cases: 1) aggregation analysis of fixed dimensions and 2) analysis of arbitrary dimensions of the original detailed data."}),"\n",(0,t.jsx)(i.p,{children:"For example, consider an E-commerce business, the order data contains the following dimensions:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"item_id"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"sold_time"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"customer_id"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"price"})}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The two mentioned use cases are both valid since the users need to:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["get the sales number of a certain item on a certain day, so we need to aggregate price on the ",(0,t.jsx)(i.code,{children:"item_id"})," and ",(0,t.jsx)(i.code,{children:"sold_time"})," dimensions;"]}),"\n",(0,t.jsx)(i.li,{children:"analyze the transaction details of a certain item by a certain person on a certain day."}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["In the existing StarRocks data model, if you create only one table with aggregation model, for example a table with ",(0,t.jsx)(i.code,{children:"item_id"}),", ",(0,t.jsx)(i.code,{children:"sold_time"}),", ",(0,t.jsx)(i.code,{children:"customer_id"}),", ",(0,t.jsx)(i.code,{children:"sum(price)"}),", you are not able to analyze detailed data since the aggregation drops some information of the data. If only a duplicate model is built, you can run queries on all the dimension, but the queries will not be accelerated because of lack of Rollup support. If you build a table with the aggregation model and a table with the duplicate model at the same time, you can get both the performance and can run queries on all the dimensions, but the two tables are not related to each other, so you need to choose the analysis table manually. It doesn\u2019t offer good flexibility and usability."]}),"\n",(0,t.jsx)(i.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,t.jsxs)(i.p,{children:["Queries that use aggregation functions such as ",(0,t.jsx)(i.code,{children:"sum"})," and ",(0,t.jsx)(i.code,{children:"count"})," can be executed more efficiently in tables that already contain aggregated data. You would want the improved efficiency when querying large amounts of data. The data in the table is materialized in a storage node and can be kept consistent with the base table in incremental updates. After a user creates a MVs table, the query optimizer will select and query the most efficient MVs table instead of using the base table. Since the data in MVs tables is typically much smaller than the base table, queries are more efficient."]}),"\n",(0,t.jsx)(i.h3,{id:"build-a-materialized-view",children:(0,t.jsx)(i.strong,{children:"Build a materialized view"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW materialized_view_name\nAS SELECT id, SUM(clicks) AS sum_clicks\nFROM  database_name.base_table\nGROUP BY id ORDER BY id\u2019\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The creation of a materialized view is currently an asynchronous operation. The command for materialized view creation returns immediately, but the creation may still be running. You can use the ",(0,t.jsx)(i.code,{children:'DESC "base_table_name" ALL'})," command to see the current materialized view of the base table. You can use the ",(0,t.jsx)(i.code,{children:'SHOW ALTER TABLE MATERIALIZED VIEW FROM "database_name"'})," command to check the status of the current and the historical materialized views."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Restrictions"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"partition column"})," in the base table must be one of  the ",(0,t.jsx)(i.code,{children:"group by"})," columns of the created materialized view"]}),"\n",(0,t.jsx)(i.li,{children:"Currently, only single-table materialized views are supported. No multi-table joins."}),"\n",(0,t.jsx)(i.li,{children:"Aggregation is not supported for key columns, but only for value columns.The type of aggregation operator cannot be changed."}),"\n",(0,t.jsx)(i.li,{children:"The materialized view must contain at least one key column."}),"\n",(0,t.jsx)(i.li,{children:"Expression calculation is not supported."}),"\n",(0,t.jsx)(i.li,{children:"Queries a specified materialized view is not supported."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"drop-materialized-view",children:(0,t.jsx)(i.strong,{children:"DROP MATERIALIZED VIEW"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"DROP MATERIALIZED VIEW [IF EXISTS] [db_name]. <mv_name>"})}),"\n",(0,t.jsx)(i.h3,{id:"view-materialized-views",children:(0,t.jsx)(i.strong,{children:"View materialized views"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"View all materialized views under this database"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"SHOW MATERIALIZED VIEW [IN|FROM db_name]"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"View the table structure of the specified materialized view"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"DESC table_name all"}),"\n( ",(0,t.jsx)(i.code,{children:"DESC/DESCRIBE mv_name"})," is no longer supported)"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"View the processing progress of a materialized view"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"SHOW ALTER MATERIALIZED VIEW FROM db_name"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Cancel the materialized view being created"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"CANCEL ALTER MATERIALIZED VIEW FROM db_name.table_name"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Confirm which materialized views were hit by the query"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Users do not need to know the existence of the materialized view when running the queries, which means the name of the materialized view does not have to be explicitly specified. The query optimizer can automatically determine whether the query can be routed to the appropriate materialized view. Whether the query plan is rewritten or not, it can be seen with ",(0,t.jsx)(i.code,{children:"explain SQL"}),", which can be executed on the MySQL client:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-SQL",children:"Explain SQL:\n \n0:OlapScanNode\nTABLE: lineorder4\nPREAGGREGATION: ON\npartitions=1/1\nRollUptable: lineorder4\ntabletRatio=1/1\ntabletList=15184\ncardinality=119994608\navgRowSize=26.375498\nnumNodes=1\ntuple ids: 0\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"RollUptable"})," field indicates which materialized view was hit. If the ",(0,t.jsx)(i.code,{children:"PREAGGREGATION"})," field is ",(0,t.jsx)(i.code,{children:"On"}),", the query will be faster. If the ",(0,t.jsx)(i.code,{children:"PREAGGREGATION"})," field is ",(0,t.jsx)(i.code,{children:"Off"}),", the reason will be shown. For example:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-TEXT",children:"PREAGGREGATION: OFF. Reason: The aggregate operator does not match.\n"})}),"\n",(0,t.jsx)(i.p,{children:"This indicates the physical view cannot be used in the StarRocks storage engine because the aggregation function of the query does not match the one defined in the physical view, and requires on-site aggregation."}),"\n",(0,t.jsx)(i.h3,{id:"importing-data",children:(0,t.jsx)(i.strong,{children:"Importing Data"})}),"\n",(0,t.jsx)(i.p,{children:"Incremental imports to the base table are applied to all associated MVs tables. Data cannot be queried until the import to the base table and all MVs tables are all complete. StarRocks ensures that the data is consistent between the base and MVs tables. There is no data difference between querying the base table and the MVs table."}),"\n",(0,t.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsx)(i.h3,{id:"materialized-view-function-support",children:(0,t.jsx)(i.strong,{children:"Materialized view function support"})}),"\n",(0,t.jsx)(i.p,{children:"The materialized view must be an aggregation of a single table. Only the following aggregation functions are supported currently."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"COUNT"}),"\n",(0,t.jsx)(i.li,{children:"MAX"}),"\n",(0,t.jsx)(i.li,{children:"MIN"}),"\n",(0,t.jsx)(i.li,{children:"SUM"}),"\n",(0,t.jsx)(i.li,{children:"PERCENTILE_APPROX"}),"\n",(0,t.jsx)(i.li,{children:"HLL_UNION"}),"\n",(0,t.jsxs)(i.li,{children:["Performs HLL aggregation on duplicate data and uses HLL functions to analyze querieddata. (This is mainly used for quick and non-exact de-duplication calculations. To use ",(0,t.jsx)(i.code,{children:"HLL_UNION aggregation"})," for duplicate data, you need to call the ",(0,t.jsx)(i.code,{children:"hll_hash"})," function first to transform the original data.)"]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-SQL",children:"create materialized view dt_uv as\n    select dt, page_id, HLL_UNION(hll_hash(user_id))\n    from user_view\n    group by dt, page_id;\nselect ndv(user_id) from user_view; #The query can hit the materialized view\n"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"HLL_UNION"})," aggregation operator is not supported for ",(0,t.jsx)(i.code,{children:"DECIMAL"}),"/",(0,t.jsx)(i.code,{children:"BITMAP"}),"/",(0,t.jsx)(i.code,{children:"HLL"}),"/",(0,t.jsx)(i.code,{children:"PERCENTILE"})," type columns currently."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"BITMAP_UNION"}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Users can perform BITMAP aggregation on duplicate data and use the BITMAP function to analyze the data. It is mainly used to quickly calculate the exact de-duplication of ",(0,t.jsx)(i.code,{children:"count(distinct)"}),". To use ",(0,t.jsx)(i.code,{children:"BITMAP_UNION"})," aggregation on the duplicate data, you need to call the ",(0,t.jsx)(i.code,{children:"to_bitmap function"})," first to convert the original data."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-SQL",children:"create materialized view dt_uv as\n    select dt, page_id, bitmap_union(to_bitmap(user_id))\n    from user_view\n    group by dt, page_id;\nselect count(distinct user_id) from user_view; #Query can hit the materialized view\n"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Currently, only ",(0,t.jsx)(i.code,{children:"TINYINT"}),"/",(0,t.jsx)(i.code,{children:"SMALLINT"}),"/",(0,t.jsx)(i.code,{children:"INT"}),"/",(0,t.jsx)(i.code,{children:"BITINT"})," types are supported, and the stored content must be a positive integer (including 0)."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"intelligent-routing-of-materialized-views",children:(0,t.jsx)(i.strong,{children:"Intelligent routing of materialized views"})}),"\n",(0,t.jsx)(i.p,{children:"There is no need to explicitly specify a MV\u2019s name during the query, StarRocks can intelligently route to the best MV based on the query SQL. The rules for MV selection are as follows."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Select the MV that contains all query columns"}),"\n",(0,t.jsx)(i.li,{children:"Select the most matching MV by the column defined in the query\u2019s sorting and filtering condition."}),"\n",(0,t.jsx)(i.li,{children:"Select the most matching MV by the column defined in the query\u2019s joining condition."}),"\n",(0,t.jsx)(i.li,{children:"Select the MV with the smallest number of rows"}),"\n",(0,t.jsx)(i.li,{children:"Select the MV with the smallest number of columns"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"other-restrictions",children:(0,t.jsx)(i.strong,{children:"Other restrictions"})}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"The RollUp table model must accommodate the type of the base table (Use aggregate model for aggregate tables and duplicate model for duplicate tables.)."}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"Delete"})," operation is not allowed if a key in the ",(0,t.jsx)(i.code,{children:"where"})," condition does not exist in a RollUp table. In this case, users can delete the materialized view first, then perform the ",(0,t.jsx)(i.code,{children:"delete"})," operation, and finally re-add the materialized view."]}),"\n",(0,t.jsxs)(i.li,{children:["If the materialized view contains columns of the ",(0,t.jsx)(i.code,{children:"REPLACE"})," aggregation, it must contain all key columns."]}),"\n"]})]})}const h=function(e={}){const{wrapper:i}=Object.assign({},(0,a.ah)(),e.components);return i?(0,t.jsx)(i,Object.assign({},e,{children:(0,t.jsx)(c,e)})):c(e)}},11151:(e,i,n)=>{n.d(i,{Zo:()=>r,ah:()=>s});var t=n(67294);const a=t.createContext({});function s(e){const i=t.useContext(a);return t.useMemo((()=>"function"==typeof e?e(i):{...i,...e}),[i,e])}const l={};function r({components:e,children:i,disableParentContext:n}){let r;return r=n?"function"==typeof e?e({}):e||l:s(e),t.createElement(a.Provider,{value:r},i)}}}]);