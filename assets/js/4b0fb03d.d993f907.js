"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[69338],{67152:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=t(85893),o=t(11151);const s={displayed_sidebar:"English"},i="Table Design",r={id:"table_design/StarRocks_table_design",title:"Table Design",description:"Columnar Storage",source:"@site/versioned_docs/version-2.0/table_design/StarRocks_table_design.md",sourceDirName:"table_design",slug:"/table_design/StarRocks_table_design",permalink:"/docs/2.0/table_design/StarRocks_table_design",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/edit/main/docs/table_design/StarRocks_table_design.md",tags:[],version:"2.0",frontMatter:{displayed_sidebar:"English"},sidebar:"English",previous:{title:"Sort Keys",permalink:"/docs/2.0/table_design/Sort_key"},next:{title:"Export Overview",permalink:"/docs/2.0/unloading/Export"}},d={},l=[{value:"Columnar Storage",id:"columnar-storage",level:2},{value:"Sparse Indexing",id:"sparse-indexing",level:2},{value:"Speed up data processing",id:"speed-up-data-processing",level:2}];function c(e){const n=Object.assign({h1:"h1",h2:"h2",p:"p",img:"img",code:"code",ol:"ol",li:"li"},(0,o.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"table-design",children:"Table Design"}),"\n",(0,a.jsx)(n.h2,{id:"columnar-storage",children:"Columnar Storage"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"column",src:t(69147).Z+"",width:"1616",height:"522"})}),"\n",(0,a.jsxs)(n.p,{children:["Similar to relational database tables, a StarRocks table consists of rows and columns. Each row of data corresponds to one record, and data in each column share the same data type. All data rows have the same number of columns, and columns can be added or deleted dynamically. In StarRocks, there are two types of columns --  key columns and value columns. The key columns are used for grouping and sorting, and value columns can be aggregated by ",(0,a.jsx)(n.code,{children:"SUM,"})," ",(0,a.jsx)(n.code,{children:"COUNT"}),", ",(0,a.jsx)(n.code,{children:"MIN"}),", ",(0,a.jsx)(n.code,{children:"MAX"}),", ",(0,a.jsx)(n.code,{children:"REPLACE"}),", ",(0,a.jsx)(n.code,{children:"HLL_UNION"}),", ",(0,a.jsx)(n.code,{children:"BITMAP_UNION"}),", etc. Therefore, a StarRocks table can also be considered as a mapping of multidimensional keys to multidimensional metrics."]}),"\n",(0,a.jsx)(n.p,{children:"In StarRocks, data is stored in table columns. Physically, a column of data is chunked, encoded, and compressed, ending up being persisted on non-volatile storage. Logically, a column of data can be viewed as a vector of elements of the same type. All columns of a row of data remain aligned in their respective column vectors, i.e., they have the same vector subscript which is called the ordinal number or row number. The ordinal number is implicit and does not need to be stored. All rows in the table are sorted multiple times by key columns, and the sorted position is the row number of that row."}),"\n",(0,a.jsxs)(n.p,{children:["When querying, if you set the equality  or range conditions of key columns and the key columns form the prefix of the table\u2019s key columns, then you can leverage the orderliness of data and use ",(0,a.jsx)(n.code,{children:"range-scan"})," to quickly target rows. Take table1: ",(0,a.jsx)(n.code,{children:"event_day, siteid, citycode, username"}),"\u279c",(0,a.jsx)(n.code,{children:"pv"})," for instance. If the query condition is ",(0,a.jsx)(n.code,{children:"event_day > 2020-09-18 and siteid = 2"}),", then you can use range-scan; if the query condition is ",(0,a.jsx)(n.code,{children:"citycode = 4"})," and username in ",(0,a.jsx)(n.code,{children:'["Andy", "Boby", "Christian", "StarRocks"]'}),", then you cannot use range-scan."]}),"\n",(0,a.jsx)(n.h2,{id:"sparse-indexing",children:"Sparse Indexing"}),"\n",(0,a.jsxs)(n.p,{children:["When performing range search, how to quickly find the beginning and end of the target row? The answer is ",(0,a.jsx)(n.code,{children:"shortkey indexing"})," (aka sparse indexing) as shown below."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"index",src:t(52525).Z+"",width:"1796",height:"926"})}),"\n",(0,a.jsx)(n.p,{children:"The data table consists of three components:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Shortkey index table: The shortkey index is a sparse index. Every 1024 rows of data constitute a logical block. Each logical block stores an index in the shortkey index table. The index contains the first 36 bytes of the starting row which can be used to locate the starting row of the block."}),"\n",(0,a.jsx)(n.li,{children:"Per-column data block: Each column of data is stored in 64KB chunks, and the data block is encoded and compressed as an I/O unit to support data read and write."}),"\n",(0,a.jsx)(n.li,{children:"Per-column cardinal index: Each column of data has its own per-column cardinal index. The index consists of the starting row number, position, and length information of the data block. With the starting row number, you can locate the index and get the other information of the data."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Thus, the process to find the prefix of the key column is as follows:\nFirst,  look up the shortkey index, and get the starting row number of the logical block;\nSecond,  look up the per-column cardinal index, and get the data block of the target column;\nThird, read the data block, that is, to decompress and decode it to get the data item corresponding to the prefix of the key column."}),"\n",(0,a.jsx)(n.h2,{id:"speed-up-data-processing",children:"Speed up data processing"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Pre-aggregation: StarRocks supports an aggregation model where data rows with the same key column values can be merged. The key column values of the merged rows remain unchanged, while the value column shows aggregated results. The user needs to specify the aggregation function for the value column. The aggregation operation can be accelerated by pre-aggregation."}),"\n",(0,a.jsx)(n.li,{children:"Partitioning and bucketing: In fact, StarRocks tables are divided into tablets whose replicas are stored on BEs. The number of BEs and tablets can be scaled according to computing resources and data size. When querying, multiple BEs can be used in parallel to look up tablets  and get data quickly. In addition, the tablet replicas can be copied and migrated, which enhances data reliability and avoids data skew. In short, partitioning and bucketing ensure query efficiency and stability."}),"\n",(0,a.jsx)(n.li,{children:"RollUp table index: Shortkey indexing leverages the sequence of key columns to speed up queries. If you use non-prefixed key columns as a query condition, shortkey indexing won\u2019t work. In this case, you can create several RollUp table indexes. The data layout and storage of RollUp table indexes are the same as tables. However, RollUp tables have their own shortkey indexes. When creating the RollUp tables, you can design the dimension of aggregation, the number of columns, and the sequence of the key columns, to ensure that frequently used query conditions will hit the corresponding RollUp table indexes."}),"\n",(0,a.jsx)(n.li,{children:"Columnar indexing techniques: Bloomfilter can quickly determine whether the data block contains the queried value, ZoneMap can quickly filter the value bydata range, and Bitmap indexes can quickly find the target row from the columns of enumerated types that satisfy certain conditions."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For more details on table design, see the following sections."})]})}const h=function(e={}){const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(c,e)})):c(e)}},69147:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/3.1.1-1-045c6e78dd6c518263231224bd5130b6.png"},52525:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/3.1.1-2-f248a9fa17f5f42e9a970f7b9df65907.png"},11151:(e,n,t)=>{t.d(n,{Zo:()=>r,ah:()=>s});var a=t(67294);const o=a.createContext({});function s(e){const n=a.useContext(o);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const i={};function r({components:e,children:n,disableParentContext:t}){let r;return r=t?"function"==typeof e?e({}):e||i:s(e),a.createElement(o.Provider,{value:r},n)}}}]);