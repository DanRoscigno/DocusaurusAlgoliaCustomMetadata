"use strict";(self.webpackChunkstarrocks=self.webpackChunkstarrocks||[]).push([[10069],{19619:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>p});var s=n(85893),r=n(11151);const t={},l="map_apply",o={id:"sql-reference/sql-functions/map-functions/map_apply",title:"map_apply",description:"Description",source:"@site/versioned_docs/version-3.0/sql-reference/sql-functions/map-functions/map_apply.md",sourceDirName:"sql-reference/sql-functions/map-functions",slug:"/sql-reference/sql-functions/map-functions/map_apply",permalink:"/doc/docs/3.0/sql-reference/sql-functions/map-functions/map_apply",draft:!1,unlisted:!1,editUrl:"https://github.com/StarRocks/starrocks/tree/main/versioned_docs/version-3.0/sql-reference/sql-functions/map-functions/map_apply.md",tags:[],version:"3.0",frontMatter:{},sidebar:"Chinese31",previous:{title:"element_at",permalink:"/doc/docs/3.0/sql-reference/sql-functions/map-functions/element_at"},next:{title:"map_keys",permalink:"/doc/docs/3.0/sql-reference/sql-functions/map-functions/map_keys"}},c={},p=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return value",id:"return-value",level:2},{value:"Examples",id:"examples",level:2}];function i(e){const a=Object.assign({h1:"h1",h2:"h2",p:"p",a:"a",code:"code",pre:"pre",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h1,{id:"map_apply",children:"map_apply"}),"\n",(0,s.jsx)(a.h2,{id:"description",children:"Description"}),"\n",(0,s.jsxs)(a.p,{children:["Applies a ",(0,s.jsx)(a.a,{href:"/doc/docs/3.0/sql-reference/sql-functions/Lambda_expression",children:"Lambda expression"})," to the keys and values of the original Map and generates a new Map. This function is supported from v3.0."]}),"\n",(0,s.jsxs)(a.p,{children:["From v2.5, StarRocks supports querying complex data types MAP and STRUCT from data lakes. MAP is an unordered collection of key-value pairs, for example, ",(0,s.jsx)(a.code,{children:'{"a":1, "b":2}'}),"."]}),"\n",(0,s.jsxs)(a.p,{children:["You can use external catalogs provided by StarRocks to query MAP and STRUCT data from Apache Hive\u2122, Apache Hudi, and Apache Iceberg. You can only query data from ORC and Parquet files. For more information about how to use external catalogs to query external data sources, see ",(0,s.jsx)(a.a,{href:"/doc/docs/3.0/data_source/catalog/catalog_overview",children:"Overview of catalogs"})," and topics related to the required catalog type."]}),"\n",(0,s.jsx)(a.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-Haskell",children:"MAP map_apply(lambda_func, any_map)\n"})}),"\n",(0,s.jsx)(a.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.code,{children:"lambda_func"}),": the Lambda expression."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.code,{children:"any_map"}),": the map to which the Lambda expression is applied."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"return-value",children:"Return value"}),"\n",(0,s.jsx)(a.p,{children:"Returns a map value. The data types of keys and values in the result map are determined by the result of the Lambda expression."}),"\n",(0,s.jsx)(a.p,{children:"If any input parameter is NULL, NULL is returned."}),"\n",(0,s.jsx)(a.p,{children:"If a key or value in the original map is NULL, NULL is processed as a normal value."}),"\n",(0,s.jsx)(a.p,{children:"The Lambda expression must have two parameters. The first parameter represents the key. The second parameter represents the value."}),"\n",(0,s.jsx)(a.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(a.p,{children:["The following example uses ",(0,s.jsx)(a.a,{href:"map_from_arrays.md",children:"map_from_arrays()"})," to generate a map value ",(0,s.jsx)(a.code,{children:'{1:"ab",3:"cd"}'}),'. Then the Lambda expression increments each key by 1 and calculates the length of each value. For example, the length of "ab" is 2.']}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-SQL",children:'mysql> select map_apply((k,v)->(k+1,length(v)), col_map)\nfrom (select map_from_arrays([1,3],["ab","cd"]) as col_map)A;\n+--------------------------------------------------+\n| map_apply((k, v) -> (k + 1, length(v)), col_map) |\n+--------------------------------------------------+\n| {2:2,4:2}                                        |\n+--------------------------------------------------+\n1 row in set (0.01 sec)\n\nmysql> select map_apply((k,v)->(k+1,length(v)), col_map)\nfrom (select map_from_arrays(null,null) as col_map)A;\n+--------------------------------------------------+\n| map_apply((k, v) -> (k + 1, length(v)), col_map) |\n+--------------------------------------------------+\n| NULL                                             |\n+--------------------------------------------------+\n1 row in set (0.02 sec)\n\nmysql> select map_apply((k,v)->(k+1,length(v)), col_map)\nfrom (select map_from_arrays([1,null],["ab","cd"]) as col_map)A;\n+--------------------------------------------------+\n| map_apply((k, v) -> (k + 1, length(v)), col_map) |\n+--------------------------------------------------+\n| NULL                                             |\n+--------------------------------------------------+\n'})})]})}const d=function(e={}){const{wrapper:a}=Object.assign({},(0,r.ah)(),e.components);return a?(0,s.jsx)(a,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}},11151:(e,a,n)=>{n.d(a,{Zo:()=>o,ah:()=>t});var s=n(67294);const r=s.createContext({});function t(e){const a=s.useContext(r);return s.useMemo((()=>"function"==typeof e?e(a):{...a,...e}),[a,e])}const l={};function o({components:e,children:a,disableParentContext:n}){let o;return o=n?"function"==typeof e?e({}):e||l:t(e),s.createElement(r.Provider,{value:o},a)}}}]);